<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>lxiaox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="lxiaox">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="lxiaox">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lxiaox">
  
    <link rel="alternate" href="/atom.xml" title="lxiaox" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lxiaox</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JS数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/25/JS数据结构/" class="article-date">
  <time datetime="2018-08-25T03:11:17.000Z" itemprop="datePublished">2018-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/25/JS数据结构/">JS中的数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天简要总结一下 JS 中的几种数据结构。</p>
<h2 id="1、哈希"><a href="#1、哈希" class="headerlink" title="1、哈希"></a>1、哈希</h2><blockquote>
<p>哈希表(Hash table，也叫散列表)，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
</blockquote>
<p>简单地说，形如键值一一对应的数据结构就是哈希。用哈希可以表示JS中的对象，根据是key-value对应，key表示对象属性，value表示属性值。如：</p>
<pre><code>var student = {
    &apos;name&apos;: &apos;Mary&apos;,
    &apos;sex&apos;: &apos;female&apos;,
    &apos;age&apos;: &apos;18&apos;,
  //&apos;key&apos;: &apos;value&apos;
}
</code></pre><p>其实<strong>数组</strong>就是一个特殊的哈希，它的 key 为排列好的数字,并且有一个key 是 length，表示数组长度。</p>
<pre><code>var array = [0,1,2,3]
//可以看作
var array = {
    &apos;0&apos;: 0,
    &apos;1&apos;: 1,
    &apos;2&apos;: 2,
    &apos;3&apos;: 3,
    &apos;length&apos;: 4
}
</code></pre><p>数组的优点是容易查找修改，缺点是难以在元素中间增加删除，因为每在中间增加或删除几个元素都意味着它之后的所有元素就要进行大挪移，都前进或都后退几位。</p>
<h2 id="2、栈"><a href="#2、栈" class="headerlink" title="2、栈"></a>2、栈</h2><p>栈是一种遵从<strong>后进先出</strong>（Last In First Out）的有序列表。栈顶元素永远是最新元素，每次只能从栈顶开始取出。可以想象成放在一只小箱子里的书本，每次往里放都放在最上面，也只能从最上面开始拿。栈的特点就是 先进后出，后进先出。</p>
<p>栈需要有如下的方法:</p>
<ul>
<li>push(element(s)): 添加几个元素到栈顶</li>
<li>pop(): 移除并返回栈顶元素</li>
<li>peek(): 返回栈顶元素</li>
<li>isAmpty: 检查栈是否为空，为空则返回true</li>
<li>clear: 移除栈中所有元素</li>
<li>size: 返回栈中元素个数。</li>
<li>print: 以字符串显示栈中所有内容</li>
</ul>
<h2 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h2><p>对列与栈很像，不过特点是 <strong>先进先出</strong>，这就跟我们人的排队是一样的。每次添加只能加在最后面，移除只能移除最前面的数据。</p>
<p>队列需要的方法：</p>
<ul>
<li>enqueue(element(s)): 向队列尾部添加几个项</li>
<li>dequeue(): 移除队列的第一项</li>
<li>front(): 返回队列的第一个元素</li>
<li>其他方法同栈一样。</li>
</ul>
<h2 id="4、链表"><a href="#4、链表" class="headerlink" title="4、链表"></a>4、链表</h2><blockquote>
<p>链表是一组节点组成的集合，每个节点都使用一个对象的引用来指向它的后一个节点。指向另一节点的引用讲做链。</p>
</blockquote>
<ol>
<li>单向链表中每个节点都具有两个部分，一个储存自身信息，一个指向下一个节点。</li>
<li>双向链表中每个节点则具有三个部分，一个储存自身信息，一个指向上一个节点，一个指向下一个节点。</li>
</ol>
<p>因此链表区别于数组的是容易增加删除，只需要改变指针指向即可，但是它想要找到一个节点却很困难，只能从第一个节点开始不停地找下一个节点直到找到。</p>
<p><em>队列、栈可以用数组实现，而链表可以用哈希（即JS 对象）实现。</em></p>
<p>这里说一下，哈希正是一种结合了数组和链表的优点的数据结构，既容易寻址查找，又容易插入删除。</p>
<h2 id="5、树"><a href="#5、树" class="headerlink" title="5、树"></a>5、树</h2><p>之前的栈、队列、链表等都是顺序数据结构，而树就是一种<strong>非顺序结构</strong>。树形状像一颗根在上的倒挂的树，以此命名，如下图：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/tree1.png" alt="树"></p>
<h4 id="树的基本概念："><a href="#树的基本概念：" class="headerlink" title="树的基本概念："></a>树的基本概念：</h4><ul>
<li>节点：树中的每个元素都叫节点；</li>
<li>根节点：没有父节点的节点，树只有唯一的根节点，图中为 A；</li>
<li>子节点：从节点延申而下的都叫子节点；</li>
<li>内部节点：有子节点的节点（B C D）或称中间节点；</li>
<li>叶子节点：没有子节点的节点(E F G H I J)，又称终端节点；</li>
<li>节点层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>节点深度：从根 到 该节点的路径长，根的深度为0；</li>
<li>节点高度：从该节点 到 一个叶子节点的最长路径长，叶子节点的高度为0；</li>
<li>树的深度：所有节点深度的最大值；</li>
<li>树的高度：所有节点高度的最大值；</li>
<li>节点的度：一个节点含有的子树的个数称为该节点的度；</li>
<li>树 的 度：一棵树中，最大的节点的度称为树的度；</li>
<li>注：关于根节点的深度高度的基数为0 或1 说法不一。</li>
</ul>
<h4 id="树的种类："><a href="#树的种类：" class="headerlink" title="树的种类："></a>树的种类：</h4><ol>
<li>无序树：树中任意节点的子节点之间没有顺序关系，也称为自由树；</li>
<li>有序树：树中任意节点的子节点之间有顺序关系；<ul>
<li>二叉树：每个节点最多含有两个子树的树称为二叉树；</li>
<li>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。</li>
</ul>
</li>
</ol>
<p>其中二叉树又分为：</p>
<ul>
<li>完全二叉树：除了最底层，所有层的节点数均达到最大值，最底层的左右节点连续紧密地排列，这样的二叉树叫做完全二叉树。</li>
<li>满二叉树：所有叶子节点均在最底层的二叉树。<em>满二叉树和完全二叉树用数组就可以表示</em>。</li>
</ul>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/%E6%BB%A1-%E5%AE%8C%E5%85%A8-%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="满/完全二叉树"></p>
<ul>
<li>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li>
<li>排序二叉树(二叉查找树)：只允许你在左侧节点储存比父节点小的值，右侧只允许储存比父节点大的值。也称二叉搜索树、有序二叉树；</li>
</ul>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="二叉查找树"></p>
<h5 id="还有一种特殊的数据结构—-堆"><a href="#还有一种特殊的数据结构—-堆" class="headerlink" title="还有一种特殊的数据结构—-堆"></a>还有一种特殊的数据结构—-堆</h5><p><strong>堆(heap)</strong>，形状上像完全二叉树，堆的特点是所有父节点都比它的子节点要大（最大堆） 或者要小（最小堆）。正如我们堆东西将大的放下面，小的放上面，树不能表现出这种特性，所以叫做堆。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/25/JS数据结构/" data-id="cjmlkb38v000dhs7ljtzvo4zf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（J）JS-数据结构/">（J）JS-数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/23/JS排序算法/" class="article-date">
  <time datetime="2018-08-23T03:54:32.000Z" itemprop="datePublished">2018-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/23/JS排序算法/">JS排序算法（学习ing）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不断更新中……</p>
<p>冒泡O(n^2)，选择O(n^2)，插入O(n^2)，快速，计数，归并，桶排序，基数排序……</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>基本思想：重复走访要排序的数列，一次比较两个元素，如果这两个数顺序错误就将其交换，每次走访都能找到一个最值，重复走访直到没有要进行交换的元素，那么排序就完成了。</li>
<li>时间复杂度：O(n^2)</li>
<li>冒泡排序过程（升序）：<ol>
<li>比较第一对相邻的元素，如果第一个比第二个大，就交换他们两个。</li>
<li>按1的方法比较第二对相邻元素，即第二个与第三个，以此类推直到最后一对元素，这时，最后的元素就是最大的数。</li>
<li>再次重复步骤1、2比较除最后一个数的所有元素。</li>
<li>如此每次都找到一个当前最大值下次不需在参与比较，直到没有任何一对数字需要比较。</li>
</ol>
</li>
<li><p>JS 代码：</p>
<pre><code>Array.prototype.bubbleSort = function() {
    var i, j, temp;
        //每轮比较让最大的冒到最上面，i：轮数=元素个数-1，因为this[0]不需要再比较。
    for (i = 0; i &lt; this.length - 1; i++)
            //每次选定this[j+1],所以j&lt;this.length-1; 第一轮j+1=this.length-1,第二轮j+1=this.length-2,...所以是要-i
        for (j = 0; j &lt; this.length - 1 - i; j++)
            if (this[j] &gt; this[j + 1]) {
                temp = this[j];
                this[j] = this[j + 1];
                this[j + 1] = temp;
            }
    return this;
};
var num = [2,9,5,8,10,1,32]
num.bubbleSort()
console.log(num)    // [1, 2, 5, 8, 9, 10, 32]
</code></pre></li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li>基本思想：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>
<li>时间复杂度：O(n^2)</li>
<li><p>JS 代码：</p>
<pre><code>Array.prototype.selectionSort = function() {
    var i, j, temp, min
        //每次选出最小的作为this[i]，i：选择的轮数=元素个数-1
    for (i = 0; i &lt; this.length - 1; i++) {
          min = i
            //每次从this[i]比较到最后一个：this.length-1；
        for (j = i + 1; j &lt; this.length; j++) {
            if (this[j] &lt; this[min]) {
              min = j
            }
        }
      temp = this[i]
      this[i] = this[min]
      this[min] = temp
    }            
    return this
}
var num = [2,9,5,8,10,1,32]
num.selectionSort()
console.log(num)    // [1, 2, 5, 8, 9, 10, 32]
</code></pre></li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>基本思想：将第一个元素视为已排列元素，取出下一个元素从后向前地与已排列元素进行对比，如果下一个元素（即新元素）比某个元素小，就将这个元素往后移一位，一直比较直到找到小于或等于新元素的，将新元素插到这个元素之后，再重复将多有元素排完。</li>
<li>时间复杂度：O(n^2)</li>
<li><p>JS 代码：</p>
<pre><code>Array.prototype.insertionSort = function() {
  var i, j
    //i表示待插入元素，从1开始，因为第一个已插到this[0]
  for(i = 1; i &lt; this.length; i++) {
    for(j = 0; j &lt; i; j++){
      if(this[i] &lt; this[j]){
            //默认j(0~i-1)是已经排好的，this[i]是待插的
            //this[i]&lt;this[j],则把它插入到this[j]的位置
        this.splice(j,0,this[i])
            //把this[i]插到this[j]之后，原来的this[i]变成了this[i+1]，把它删掉
        this.splice(i+1,1)
        break
      }
    }
  }
}
var num = [2,9,5,8,10,1,32]
num.insertionSort()
console.log(num)    // [1, 2, 5, 8, 9, 10, 32]
</code></pre></li>
</ul>
<p>点击<a href="https://visualgo.net/en" target="_blank" rel="noopener">查看排序动画的网站</a>，可以更直观地了解排序的具体过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/23/JS排序算法/" data-id="cjmlkb38r000bhs7lt6a4qif6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（S）排序算法-js/">（S）排序算法-js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AJAX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/23/AJAX/" class="article-date">
  <time datetime="2018-08-23T01:59:51.000Z" itemprop="datePublished">2018-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/23/AJAX/">AJAX</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前我们介绍了JSONP与跨域，JSONP是一种通过 script 发送请求的跨域技术，但是我们也提到了 jsonp 的缺点：</p>
<p>那就是 jsonp 是通过 script 只能发送 GET 请求，并只能以脚本运行。</p>
<p>那么有没有方式能实现各种请求方式<code>（get、post、put、delete...）</code>，并且我们想以什么方式展示都可以呢？</p>
<p>针对这个需求，微软率先做出了突破：</p>
<p>IE 5 在JS中引入了一个 ActiveX 对象，使得 JS 可以直接发起 HTTP 请求，随后 Mozilla、Safari、Opera 等浏览器也引进该对象。</p>
<p>该对象被纳入 <a href="https://www.w3.org/Consortium/" target="_blank" rel="noopener">W3C</a> 规范，取名为 <code>XMLHttpRequest</code> 。</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>使用上述对象  XMLHttpRequest 发送请求的步骤：</p>
<ol>
<li>使用 XMLHttpRequest 发请求，</li>
<li>服务器返回XML格式的字符串（现在大多使用<a href="https://www.json.org/" target="_blank" rel="noopener">JSON</a>格式），</li>
<li>JS 解析 XML ，并更新局部页面。</li>
</ol>
<p><a href="https://zh.wikipedia.org/wiki/%E5%82%91%E8%A5%BF%C2%B7%E8%A9%B9%E5%A7%86%E5%A3%AB%C2%B7%E8%B3%88%E7%91%9E%E7%89%B9" target="_blank" rel="noopener">Jesse James Garrett</a> 将以上技术取名为 <code>AJAX</code> ，全称是 <code>Asynchronous JavaScript And XML</code>，意为异步的 JavaScript 和 <a href="https://zh.wikipedia.org/zh-hans/XML" target="_blank" rel="noopener">XML</a>。</p>
<h2 id="用原生JS发-AJAX-请求实例"><a href="#用原生JS发-AJAX-请求实例" class="headerlink" title="用原生JS发 AJAX 请求实例"></a>用原生JS发 AJAX 请求实例</h2><p>上文提到使用 AJAX 的基本步骤，现在写一个请求实例。<br>客户端JS代码：</p>
<pre><code>//页面中有一个 myButton 按钮，点击它发送请求。
myButton.addEventListener(&apos;click&apos;,(e)=&gt;{
    //创建XMLHttpRequest对象
    let request = new XMLHttpRequest()
    //配置请求：动作，协议，域名，路径...
    request.open(&apos;get&apos;,&apos;http://baidu.com/xyz&apos;)
    //1、发送XML请求
    request.send()
    //2、服务器发送XML(JSON)字符串
    //3、JS解析XML
    request.onreadystatechange = ()=&gt;{
        if(request.readyState === 4){
            if(request.status &gt;= 200 &amp;&amp; request.status &lt;300){
                let string = request.responseText
                //把JSON格式的字符串转换为JS对应值
                let object = wndow.JSON.parse(string)
            }else if(request.status &gt;= 400){
                console.log(&apos;说明请求失败&apos;) 
             }
        }
    }
})
</code></pre><p>服务端部分代码：</p>
<pre><code>if(path===&apos;/xxx&apos;){
    response.statusCode = 200
    //设置响应第四部分数据格式为json格式
    response.setHeader(&apos;Content-Type&apos;, &apos;text/json;charset=utf-8&apos;)
    //跨域
    response.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://abcdef.com:8001&apos;)
    response.write(`
    {
      &quot;note&quot;:{
        &quot;to&quot;: &quot;B同学&quot;,
        &quot;from&quot;: &quot;A同学&quot;,
        &quot;heading&quot;: &quot;打招呼&quot;,
        &quot;content&quot;: &quot;hi&quot;
      }
    }
    `)
    response.end()
</code></pre><p>上述代码即使用AJAX发送请求，及服务器返回数据的过程。</p>
<p>其中值得注意的是：<br> <code>response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;http://abcdef.com:8001&#39;)</code><br>这一行代码就是为了应对浏览器的同源策略（只有协议+域名+端口完全一致才能获取到请求的数据）的机制，</p>
<p>叫做 <code>CORS ( Cross-Origin Resource Sharing)</code>，即跨站资源共享。</p>
<p>代码中 <code>Access-Control-Allow-Origin</code> 告诉浏览器，允许后面的网页跨域访问。</p>
<h2 id="封装一个-ajax"><a href="#封装一个-ajax" class="headerlink" title="封装一个 ajax()"></a>封装一个 ajax()</h2><p>为了方便使用AJAX发送请求，我们可以将上面的客户端代码封装成一个函数 ajax()：</p>
<pre><code>window.jQuery.ajax = function(url,method,body,headers,success, fail){
    let request = new XMLHttpRequest()
    request.open(method,url)
    for(let key in headers) {
         let value = headers[key]
          request.setRequestHeader(key, value)
    }
    request.onreadystatechange = ()=&gt;{
        if(request.readyState === 4){
            if(request.status &gt;= 200 &amp;&amp; request.status &lt;300){
                success.call(&apos;undefined&apos;,request.responseText)
            }else if(request.status &gt;= 400){
                fail.call(&apos;undefined&apos;,request)
            }
        }
    }
    request.send(body)
}
</code></pre><p>这样我们使用的时候只需将： 请求方式，路径，请求体（请求第四部分），成功函数，失败函数 传 给 ajax() 即可。</p>
<p>事实上使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">promise</a> 升级这个 ajax() 使其更加方便使用。</p>
<pre><code>//这里我们可以将参数封装成一个对象（ES6语法,解构赋值）
window.jQuery.ajax = function({url,method,body,headers}){
    return new Promise(function(resolve, reject) {
        let request = new XMLHttpRequest()
        request.open(method, url)
        for(let key in headers) {
             let value = headers[key]
              request.setRequestHeader(key, value)
        }
        request.onreadystatechange = () =&gt; {
            if (request.readyState === 4) {
                if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) {
                    resolve.call(&apos;undefined&apos;, request.responseText)
                } else if (request.status &gt;= 400) {
                    reject.call(&apos;undefined&apos;, request)
                }
            }
        }
        request.send(body)
    })
}

//按以下方式调用
jQuery.ajax({
    url: &apos;/xxx&apos;,
    method: &apos;get&apos;
}).then(success, fail)
</code></pre><h2 id="AJAX-的功能"><a href="#AJAX-的功能" class="headerlink" title="AJAX 的功能"></a>AJAX 的功能</h2><ul>
<li>客户端的 JS 发送请求</li>
<li>服务端的 JS 发送响应</li>
</ul>
<p>一、客户端 JS 设置请求各部分：</p>
<ol>
<li>第一部分 <code>request.open(&#39;get&#39;, &#39;/xxx&#39;)</code></li>
<li>第二部分 <code>request.setHeader(&#39;content-type&#39;,&#39;x-www-form-urlencoded&#39;)</code></li>
<li>第四部分 <code>request.send(&#39;a=1&amp;b=2&#39;)</code></li>
</ol>
<p>二、客户端 JS 获取响应各部分</p>
<ol>
<li>第一部分 <code>request.status（响应码） / request.statusText（响应码解释）</code></li>
<li>第二部分 <code>request.getResponseHeader() / request.getAllResponseHeaders()（一个或所有响应头）</code></li>
<li>第四部分 <code>request.responseText</code></li>
</ol>
<p>三、服务端 JS 获取请求各部分</p>
<ol>
<li>第一部分 <code>request.method，request.url</code></li>
<li>第二部分 <code>request.header</code></li>
<li>第四部分 <code>request.body</code></li>
</ol>
<p>四、服务端 JS 设置响应各部分：</p>
<ol>
<li>第一部分 <code>response.statusCode = 200</code></li>
<li>第二部分 <code>response.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf-8&#39;)</code></li>
<li>第四部分 <code>response.write(&#39;hi...&#39;)</code></li>
<li>响应结束 <code>response.end()</code></li>
</ol>
<p>另：本文中使用了</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">promise语法</a></li>
<li><a href="https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html" target="_blank" rel="noopener">回调函数</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/23/AJAX/" data-id="cjmlkb37z0000hs7lqyazjwyn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（W）ajax/">（W）ajax</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JSONP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/17/JSONP/" class="article-date">
  <time datetime="2018-08-17T02:22:50.000Z" itemprop="datePublished">2018-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/17/JSONP/">JSONP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JSONP（全称是 JSON with Padding）是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。JSONP通过GET请求向服务器请求数据。</p>
<h2 id="浏览器发送请求的历史"><a href="#浏览器发送请求的历史" class="headerlink" title="浏览器发送请求的历史"></a>浏览器发送请求的历史</h2><p>在了解JSONP之前，先来看看在JSONP之前浏览器是怎么向服务器发送请求的，前端程序员经过长时间的探索，曾先后使用过form、img等标签发请求，然而</p>
<ul>
<li>form（可以发送post、get等请求）表单会刷新页面，在新的页面中显示成功或失败，这个时候可以将新页面展示在iframe中，但这专门用来防止刷新的iframe无疑是碍眼的；</li>
<li>img标签（发送get请求）只知道成功、失败，无法获取更多的数据；</li>
<li>a标签（发送get请求）同样会刷新页面；</li>
<li>link（发送get请求）只能以css、favcon的形式展示；</li>
</ul>
<h2 id="SRC"><a href="#SRC" class="headerlink" title="SRC"></a>SRC</h2><p>那有什么办法能够更好的发送请求并得到数据呢？程序员发现script标签很好地实现了这种需求，并将这种解决策略称为<strong>SRC</strong>（Server Rendered JavaScript）即服务器返回JS。顾名思义，在这种方法中，浏览器向服务器请求script，服务器则进行相关操作，并返回一段JS数据告诉客户端也就是浏览器页面进行局部刷新。</p>
<p>接下来看客户端的代码：</p>
<pre><code>&lt;body&gt;
    &lt;p style=&quot;color:red;&quot;&gt;您的余额是&lt;span id=amount&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;&lt;/p&gt;
    &lt;button id=button&gt;付款&lt;/button&gt;
    &lt;script&gt;
        $(&apos;#button&apos;).on(&apos;click&apos;,function(){
           //首先新建一个scrippt标签，路径为/pay
           let script=document.createElement(&apos;script&apos;) 
           script.src=&apos;pay&apos; 
           document.body.appendChild(script)
           //加载成功后删除这个script，节省内存
           script.onload=function(e){
                e.currentTarget.remove()
            }
           //script加载失败通知用户
           script.onerror=function(e){
                alert(&apos;fail&apos;); 
                e.currentTarget.remove()
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre><p>服务端代码：</p>
<pre><code>if(path === &apos;/&apos;){
    let string=fs.readFileSync(&apos;./index.html&apos;,&apos;utf8&apos;)
    let amount=fs.readFileSync(&apos;./db&apos;,&apos;utf8&apos;)
    //这里的db为自建的文件充当数据库
    string=string.replace(&apos;&amp;&amp;&amp;amount&amp;&amp;&amp;&apos;,amount)
    response.statusCode = 200
    //写响应头
    response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;)
    //响应体，即返回给浏览器的内容
    response.write(string)
    response.end()
} else if (path === &apos;/pay&apos;){
    let amount=fs.readFileSync(&apos;./db&apos;,&apos;utf8&apos;)
    amount--    //付款1元，余额减1
    //新的余额写进数据库
    fs.writeFileSync(&apos;./db&apos;,amount)  
    response.statusCode = 200
    response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript;charset=utf-8&apos;)
    //这里是返回给客户端的JS代码
    response.write(`
      amount.innerText--
    `) 
    response.end()
}
</code></pre><p>这就是SRC的流程，然而这段代码中还存在着一个问题，不难看出，这里是由后端代码返回操作页面的JS代码，这就要求后端程序员掌握前端代码写法，并且必须对页面内容非常地熟悉，我们把这种代码杂糅称为代码的耦合，那么，为了解决这个问题，就说到了今天的重头戏–JSONP。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>上面说到了解决代码耦合，方法就是将上述后端写的前端代码，先封装为一个函数写在js中，发送script请求时，同时将这个函数作为请求参数传给服务器，这样后端就不需要写这些代码，只需要调用这个函数就行了。<br>代码修改如下：</p>
<pre><code>//1、客户端加上请求参数
//注意，为了统一，请求参数的名字规定叫做callback，以便所有人使用
script.src=&apos;/pay?callback=函数名&apos;
//2、封装函数，注意这里的函数名一般都加上随机以免造成变量名冲突。
//例如: let 函数名 = &apos;xxx&apos; + parseInt(Math.random()*10000,10)
window.函数名=function(result){
        amount.innerText = result.left
}

//3、服务器，修改原来的请求头数据格式javascript为json
response.setHeader(&apos;Content-Type&apos;, &apos;application/json;charset=utf-8&apos;)
//4、修改响应第四部分，调用请求参数callback即我们传入的 函数
response.write(`
    ${query.callback}.call(undefined,{
        &quot;success&quot;:true,
        &quot;left&quot;:${amount}
    })
`)
</code></pre><p>在上面的服务器代码响应第四部分中，给函数传入了参数：</p>
<pre><code>${query.callback}.call(undefined,{
    &quot;success&quot;:true,
    &quot;left&quot;:${amount}
})
</code></pre><p>这个参数包含了执行结果（成功）以及返回的数据（新的余额），这个参数的数据格式就是JSON对象，它左右的内容 <code>${query.callback}.call(undefined,</code> 与 <code>)</code>  分别是 左padding 和 右padding，这就是 <code>Json with Padding</code> 名字的由来。</p>
<p>当然，理论上这里的参数实际上并不一定需要JSON对象，只是对象能表示更多的数据，并且JSON对象能被JS解析，如果你想学习JSON，<a href="https://www.json.org/" title="这里是JSON官网" target="_blank" rel="noopener">点击去JSON官网</a>。</p>
<h2 id="JSONP与跨域"><a href="#JSONP与跨域" class="headerlink" title="JSONP与跨域"></a>JSONP与跨域</h2><p>上述讲了浏览器是怎么通过 JSONP 发送请求得到数据的，似乎还没提到怎么实现跨域。</p>
<blockquote>
<p>先来了解一下跨域：只有 <strong>协议、域名、端口</strong> 完全一样才被浏览器认为是同一个域，在一个网站中浏览器不能跨域执行另一个网站的脚本，这就是浏览器的 <strong>同源策略</strong>，也就是说你可以跨域发送请求，但是请求到的非同源数据会被拦截。浏览器的同源策略保护了数据的安全，但同时也造成了一些问题，比如一个公司有不同的子域需要互相访问，或者调用外部API，因此有时候我们就有了跨域的需求。</p>
</blockquote>
<p>那么JSONP是怎么跨域的呢？我们已经知道了是 JSONP 通过 script 发送GET请求，事实上，<strong>script 请求是不受同源策略限制的，请求到的script资源会被立即执行</strong>，JSONP就是利用了这一特性来实现跨域。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后来总结一下 JSONP 的过程：</p>
<ol>
<li>请求方动态创建一个 script 元素，src 指向响应方，并传递一个 callback=xxx 的参数；</li>
<li>响应方作出形如 callback.call(‘undefined’,‘要的数据’) 或者 callback(‘要的数据’) 的响应；</li>
<li>请求方接到响应，调用 xxx.call(‘undefined’,‘要的数据’)；</li>
<li>这样请求方就得到了他要的数据。</li>
</ol>
<ul>
<li>为什么JSONP不能发送POST请求？<br>答案：因为JONP是通过动态创建script标签实现的，script标签只能发送GET请求。</li>
</ul>
<p>最后介绍一个jQuery使用JSONP的简单方法。</p>
<pre><code>$.ajax({
    url: &quot;http://xxx.com:8002/pay&quot;,
    dataType: &quot;jsonp&quot;,
    success: function( response ) {
        if(response === &apos;success&apos;){
            amount.innerText = amount.innerText - 1
        }
    }
})
</code></pre><p>虽然名字叫 <code>ajax</code>，但是两者并没有任何联系，事实上应该叫做 <code>jsonp</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/17/JSONP/" data-id="cjmlkb38j0005hs7l5iy89bmg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（W）jsonp/">（W）jsonp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-实现一个jQuery的API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/04/实现一个jQuery的API/" class="article-date">
  <time datetime="2018-07-04T14:20:26.000Z" itemprop="datePublished">2018-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/04/实现一个jQuery的API/">实现一个jQuery的API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通过自己动手写 API 来学习 jQuery！</p>
<h3 id="第1个API：addClass"><a href="#第1个API：addClass" class="headerlink" title="第1个API：addClass"></a>第1个API：addClass</h3><p>功能：通过节点或选择器给元素添加一个类</p>
<h3 id="第2个API：setText"><a href="#第2个API：setText" class="headerlink" title="第2个API：setText"></a>第2个API：setText</h3><p>功能：设置元素的文本内容</p>
<p>代码：</p>
<p> html：</p>
<pre><code>&lt;body&gt;
  &lt;div&gt;hello&lt;/div&gt;
  &lt;div&gt;hello&lt;/div&gt;
  &lt;div&gt;hello&lt;/div&gt;
  &lt;div&gt;hello&lt;/div&gt;
  &lt;div&gt;hello&lt;/div&gt;
&lt;/body&gt;
</code></pre><p> css： </p>
<pre><code>div{
  border:1px solid red;
  width: 150px;
  height: 25px;
  margin-top: 10px;
}
.blue{  color:blue; }
.high{  height:50px; }
.narrow{  width:60px; }
</code></pre><p>此时效果为：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-7-4/94812649.jpg" alt="原始结果"></p>
<p> js：</p>
<pre><code>//jQuery就是一个函数，传进一个节点或选择器nodeOrSelector，返回一个对象nodes。
window.jQuery = function(nodeOrSelector){
  let nodes = {}
  if(typeof nodeOrSelector === &apos;string&apos;){
    //如果参数为字符串类型，也就是代表一个选择器，就获取到选择的所有元素存入nodes。
    let temp = document.querySelectorAll(nodeOrSelector)
    for(let i = 0; i&lt;temp.length; i++){
       nodes[i] = temp[i]
    }
    nodes.length = temp.length
  }else if( nodeOrSelector instanceof Node){
        //如果参数是一个节点，那就只存一个节点；为了返回结果的一致性，仍将其存为伪数组。
        nodes = {
          0: nodeOrSelector,
          length: 1
        }
  }

  //API1 添加一个类
  nodes.addClass = function(class1){
      for(let i = 0; i&lt;nodes.length; i++){
        nodes[i].classList.add(class1)
      }

  }

    //添加多个类
    //     nodes.addClass = function(classes){
    //       classes.forEach( (value)=&gt;{
    //         for(let i = 0; i&lt;nodes.length; i++){
    //           nodes[i].classList.add(value)
    //         }
    //       })

    //     }

  //API2 设置文本内容
  nodes.setText = function(text){
    for(let i = 0; i&lt;nodes.length; i++){
     nodes[i].textContent = text 
    }

  }
  //nodes的key为0，1，2，...，length，addClass，setText等
  return nodes  
}

window.$ = jQuery    //$为代替jQuery的缩写符,同时，在变量前加上$，可以区分jQuery与Dom的变量
var $div = $(&apos;div&apos;)    //传入了选择器&apos;div&apos;,$div即返回的对象nodes
$div.addClass(&apos;blue&apos;)
//$div.addClass([&apos;blue&apos;,&apos;high&apos;,&apos;narrow&apos;])//添加多个类
$div.setText(&apos;hi&apos;) 
</code></pre><p>添加’blue’类的效果：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-7-4/73660343.jpg" alt="结果1"></p>
<p>添加多个类的效果：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-7-4/88773623.jpg" alt="结果2"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/04/实现一个jQuery的API/" data-id="cjmlkb39h000yhs7lwl8t0k2e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（J）自己实现-jQuery-API/">（J）自己实现-jQuery API</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-原型与原型链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/13/原型与原型链/" class="article-date">
  <time datetime="2018-06-13T13:37:24.000Z" itemprop="datePublished">2018-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/13/原型与原型链/">原型与原型链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="构造函数与对象"><a href="#构造函数与对象" class="headerlink" title="构造函数与对象"></a>构造函数与对象</h3><p>在JS中规定全局对象window（浏览器中是window，ECMAScript中是global）具有很多属性，例如可以用来创建各种类型对象的<code>Number()</code>、<code>String()</code>、<code>Boolean()</code>、<code>Object()</code>等构造函数。</p>
<pre><code>//用构造函数创建一个实例对象
var a = new Number(123)
a  //Number {123}
</code></pre><p>复杂对象具有各种属性，基本类型数据可以引用复杂对象的各种属性是临时创建了一个复杂对象。</p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每个函数都有一个prototype属性，它指向该函数的<strong>原型</strong>，原型里具有该函数的公用属性，为节省内存空间，将这些公用属性存为一个对象，可供多个函数引用。对象的<code>__proto__</code>属性与它的构造函数的prototype指向同一个对象。</p>
<ul>
<li><code>函数Number的prototype属性指向Number.prototype对象</code>。</li>
<li><code>Number.prototype.__proto__===Object.prototype</code>.</li>
</ul>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>每个JS对象（除null）都具有的属性，它指向该对象的原型。<br><br>在例子中 <code>a 的__proto__属性也指向 Number.prototype</code>。</p>
<h3 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h3><blockquote>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
</blockquote>
<h3 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h3><p>原型也是对象，原型也可以引用原型，同时，我们也可以创建它。</p>
<ul>
<li>JS中原型最顶层为对象创建函数的原型<code>Object.prototype</code></li>
<li><code>Object.prototype.__proto__===null</code>。</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>由相互关联的原型组成的链状结构就是原型链。</li>
</ul>
<p><br>例如关系图中红色的这条线：<br><img src="http://p8rplhkt6.bkt.clouddn.com/18-6-13/73261713.jpg" alt="关系图"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/13/原型与原型链/" data-id="cjmlkb39e000uhs7lvtz0ildu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（J）原型与原型链/">（J）原型与原型链</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS中的数据类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/09/JS中的数据类型/" class="article-date">
  <time datetime="2018-06-09T15:07:26.000Z" itemprop="datePublished">2018-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/09/JS中的数据类型/">JS中的数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="js共有七种数据类型：number、string、boolean、symbol（ES6新增）、null、undefined、object"><a href="#js共有七种数据类型：number、string、boolean、symbol（ES6新增）、null、undefined、object" class="headerlink" title="js共有七种数据类型：number、string、boolean、symbol（ES6新增）、null、undefined、object"></a>js共有七种数据类型：number、string、boolean、symbol（ES6新增）、null、undefined、object</h3><blockquote>
<p>通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。</p>
</blockquote>
<h2 id="数值（number）："><a href="#数值（number）：" class="headerlink" title="数值（number）："></a>数值（number）：</h2><blockquote>
<p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。</p>
</blockquote>
<ul>
<li>整数和小数（比如<code>1</code>、<code>1.1</code>、<code>.1</code>)。</li>
<li>也可用 科学记数法 表示: <code>1.23e2 = 123</code>。</li>
<li>二进制表示：前缀<code>0b</code>。</li>
<li>八进制表示：前缀<code>0</code>（后ES5添加<code>0o</code>）。</li>
<li>十六进制：前缀<code>0x</code>。</li>
<li><p>ES即ECMAScript：标准化JavaScript。</p>
<h2 id="字符串（string）："><a href="#字符串（string）：" class="headerlink" title="字符串（string）："></a>字符串（string）：</h2><p>定义：零或多个排在一起的字符，使用’’或””表示。</p>
</li>
<li><p><code>&#39;&#39;</code>中可以使用<code>&quot;&quot;</code>或<code>&quot;</code>，<code>&quot;&quot;</code>中可以使用<code>&#39;&#39;</code>或<code>&#39;</code>。</p>
</li>
<li>在单(双)引号中使用单(双)引号：<code>\&#39;</code> <code>\&quot;</code>。</li>
</ul>
<p>字符串只能写在一行，如果想分多行写，可以:</p>
<ul>
<li>在每一行尾加 <code>\</code>，但<code>\</code>后只能接回车换行，尤其注意不能有空格，非常坑，别这样写！</li>
<li>使用连接符<code>+</code>，行尾行首均可。</li>
<li><p>使用反引号包住多行代码，但字符串中会增加<code>换行</code>字符。</p>
<h2 id="布尔值（boolean）："><a href="#布尔值（boolean）：" class="headerlink" title="布尔值（boolean）："></a>布尔值（boolean）：</h2><p>只有表示真伪的两个特殊值，即<code>true</code>真 和 <code>false</code>假。<br><table><br><tr><th>会返回布尔值的运算符</th><td>&gt; 两元逻辑运算符： &amp;&amp; (And)，|| (Or)<br>&gt; 前置逻辑运算符： ! (Not)<br>&gt; 相等运算符：===，!==，==，!=<br>&gt; 比较运算符：&gt;，&gt;=，&lt;，&lt;=<br></td></tr><tr><th>会转为false的值</th><td>undefined、null、false、null、0、NaN、空字符串<br></td></tr><tr><th>会转为true的值</th><td>除上述的其他。包括[]、{}<br></td></tr></table></p>
<h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol:"></a>symbol:</h2><p>symbol用来生成一个全局唯一的值，但并不是字符串。symbol的名字与值无关。</p>
<h2 id="undefined："><a href="#undefined：" class="headerlink" title="undefined："></a>undefined：</h2><p>表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。一般用于不赋值的<strong>非对象</strong>：<code>var n</code>，但不是规定。</p>
<h2 id="null："><a href="#null：" class="headerlink" title="null："></a>null：</h2><p>表示空值，即此处的值为空。一般用于不赋值的<strong>对象</strong>。null转为数值时自动转为0，这样不便发现错误，于是JS之父Brendan Eich又设计了undefined，它会转为<code>NaN</code>(非数，特殊的数值)。<br><br>一个null的特例：<code>typeof null</code>值为<code>Object</code>,其它数据类型均为自身。</p>
<h2 id="对象（object）："><a href="#对象（object）：" class="headerlink" title="对象（object）："></a>对象（object）：</h2><p>对象是JS核心概念，也是最重要的数据类型。对象就是各种键值对组成的集合<code>(key-value)</code>，是以上几种基本类型的<strong>无序</strong>的组合。</p>
</li>
<li><p>object中所有<code>key</code>均为<code>string</code>，<strong>字符串</strong>。全为数字或符合标识符规范的可不加引号。</p>
</li>
<li>object中所有<code>value</code>可以为各种类型和function。类型为string时必须加引号。</li>
<li><code>Object[&#39;key&#39;]</code>，<code>key</code>必须加引号，<code>Object[key]</code>不加引号时<code>key</code>是变量，key全为数字除外，会自动转为字符串。</li>
<li><code>Object[&#39;key&#39;]</code>可以写成<code>Object.key</code>，key全为数字除外，会将<code>.</code>看成小数点。</li>
<li><code>Object[表达式]</code>是正确的，<code>Objecct[&#39;H&#39;+&#39;H&#39;]=Object[&#39;HH&#39;]</code>，注意数值键不加引号时<code>Objecct[1+2]=Object[3]</code>。</li>
<li><code>delete object[&#39;key&#39;]</code>可以删除<code>key&amp;value</code>，<code>object[&#39;key&#39;] = undefined</code>只删除<code>value</code>。</li>
<li><code>for(var key in Object)</code>可遍历对象所有可以遍历的属性，包括可以遍历的继承属性。</li>
<li><code>Object.keys()</code>API可以查看对象所有key。</li>
<li>在行首的<code>{&#39;x&#39;:&#39;y&#39;}</code>均看作代码块，所以对象要写成({‘x’:’y’})。<h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><code>typeof</code>运算符可以返回一个值的数据类型。<br><center><br><table><br><tr><th>各种值</th><th>typeof 值<br></th></tr><tr><td>string</td><td>‘string’<br></td></tr><tr><td>number</td><td>‘number’<br></td></tr><tr><td>boolean</td><td>‘boolean’<br></td></tr><tr><td>symbol</td><td>‘symbol’<br></td></tr><tr><td>undefined</td><td>‘undefined’<br></td></tr><tr><td>null<th>‘object’<br></th></td></tr><tr><td>object</td><td>‘object’<br></td></tr><tr><td>function<th>‘function’<br></th></td></tr></table><center></center></center></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/09/JS中的数据类型/" data-id="cjmlkb38o0009hs7l0666q125" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（J）JS-数据类型/">（J）JS-数据类型</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-css布局" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/27/css布局/" class="article-date">
  <time datetime="2018-05-27T05:04:48.000Z" itemprop="datePublished">2018-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/27/css布局/">css布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要介绍以下几点</p>
<ul>
<li>左右布局</li>
<li>水平居中</li>
<li>垂直居中</li>
</ul>
<hr>
<h2 id="左右布局（两个子元素或以上）"><a href="#左右布局（两个子元素或以上）" class="headerlink" title="左右布局（两个子元素或以上）"></a>左右布局（两个子元素或以上）</h2><ol>
<li><strong>利用浮动</strong><br><br>给所有子元素添加属性<code>float:left/right</code>，父元素添加clearfix类，可使子元素从左至右排列，同时添加<br><code>margin</code>可增加元素间距。但是当宽度大于父元素宽度时，子元素会换行显示。</li>
<li><strong>利用绝对定位</strong><br><br>父元素添加<code>position:relative</code>，所有子元素添加<code>position:absolute</code>，使子元素脱离文档流，再利用<code>top: px</code>使子元<br>素顶部对齐，同时使用left属性调整左右位置。</li>
</ol>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><ul>
<li><strong>行内元素&amp;类行内元素（文本、链接等）</strong><br><ol>
<li>在块级父容器中让行内元素居中，只需在<strong>父元素</strong>中使用<code>text-align: center;</code><br><br>这个方法可使<code>inline</code>、<code>inline-block</code>、<code>inline-table</code>、<code>inline</code>、<code>flex</code>等类型的元素水平居中。</li>
</ol>
</li>
<li><strong>块级元素（确定宽度）</strong><br><ol>
<li><strong>法一</strong>：将子元素<code>margin-left</code>、<code>margin-right</code>均设置为<code>auto</code>。(不确定宽度时会拉至与父元素等宽。)<br></li>
<li><strong>法二</strong>：利用绝对定位，将子元素<code>left</code>设置为父元素宽度的一半，同时<code>margin-left</code>设置为子元素宽度一半的<strong>负值</strong>。</li>
<li><strong>法3.1：</strong>利用绝对定位，并将子元素<code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code>均设置为0，并加<code>margin:auto</code>。</li>
</ol>
</li>
<li><strong>块级元素（不确定宽度）</strong><br><ol>
<li><strong>法3.2：</strong>利用绝对定位，并将子元素<code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code>均设置为0，这个方法会将子元素的宽高都拉至与父元素等宽高。<br></li>
<li><strong>法四：</strong>利用绝对定位，将子元素<code>top</code>、<code>left</code>设置为<code>50%</code>，并添加<code>transform: translate(-50%, -50%);</code> 可使子元素水平且垂直居中。<br>其中<code>left</code>、<code>translateX(-50%)</code>实现水平居中。<br></li>
<li><strong>法五：</strong> flex布局：在<strong>父元素</strong>中添加<code>display:flex;</code>、<code>justify-content:center;//水平居中</code>、<code>align-items: center;//垂直居中</code> 即可使子元素水平且垂直居中。</li>
</ol>
</li>
<li><strong>多个块级元素</strong><br><ol>
<li>对所有子元素使用<code>display:inline-block;</code>，在父元素上使用<code>text-align:center;</code>即可。</li>
<li>见<strong>法五</strong>。</li>
</ol>
</li>
</ul>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><ul>
<li><strong>行内元素</strong><br><ol>
<li>在<strong>父元素</strong>中使用<code>display:table-cell;</code>、<code>vertical-align:middle;</code> 即可使子元素垂直居中。</li>
</ol>
</li>
<li><strong>块级元素（确定高度）</strong><br><ol>
<li>同理<strong>法二</strong>，利用绝对定位，将子元素<code>top</code>设置为父元素宽度的一半，同时<code>margin-top</code>设置为子元素宽度一半的 <strong>负值</strong>。</li>
<li>见<strong>法3.1</strong>。</li>
</ol>
</li>
<li><strong>块级元素（不确定高度）</strong><br><ol>
<li>见<strong>法3.2</strong>。</li>
<li>见<strong>法四</strong>。其中<code>top</code>、<code>translateY(-50%)</code>实现垂直居中。</li>
<li>见<strong>法五</strong>。</li>
</ol>
</li>
<li><strong>多个块级元素</strong><br><ol>
<li>见<strong>法五</strong>。</li>
</ol>
</li>
</ul>
<h2 id="总结居中"><a href="#总结居中" class="headerlink" title="总结居中"></a>总结居中</h2><ul>
<li><strong>行内元素</strong><ol>
<li>水平居中：在父元素中使用<code>text-align: center;</code></li>
<li>垂直居中：在父元素中使用<code>display:table-cell;</code>、<code>vertical-align:middle;</code></li>
</ol>
</li>
<li><strong>块级元素(确定宽高)</strong><ol>
<li>利用<code>margin:auto</code>：<br><br> a.水平居中：<code>margin-left</code>、<code>margin-right</code>均设置为<code>auto</code>。<br><br> b.垂直居中不适用。 </li>
<li>绝对定位 + margin负值。</li>
<li>绝对定位 + transform</li>
<li>flex布局</li>
</ol>
</li>
<li><strong>块级元素(不确定宽高)</strong><ol>
<li>绝对定位 + transform</li>
<li>flex布局</li>
</ol>
</li>
<li><strong>多个块级元素</strong><ol>
<li>对所有子元素使用<code>display:inline-block;</code>，在父元素上使用<code>text-align:center;</code> (只适用于水平居中)。</li>
<li>flex布局</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/27/css布局/" data-id="cjmlkb39a000phs7l2nyjlf1o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（C）css布局/">（C）css布局</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTML常用标签" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/09/HTML常用标签/" class="article-date">
  <time datetime="2018-05-09T02:57:35.000Z" itemprop="datePublished">2018-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/09/HTML常用标签/">HTML常用标签及简单介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文介绍内容主要分为HTML结构、标题标签、段落标签、图形标签、一些常用标签、制表、表单、框架标签、超链接标签、字符控制、列表控制以及多媒体等。</p>
<h2 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h2><table><br><tr><td><th>标签</th><th>描述<br></th></td></tr><tr><td></td><td>DOCTYPE</td><td>指定文件类型，如html5中:<br>&lt;!DOCTYPE html&gt;<br></td></tr><tr><td></td><td>html</td><td>文档的根元素<br></td></tr><tr><td></td><td>head</td><td>网页中顶级元素，一般包含浏览器环境设置部分<br></td></tr><tr><th rowspan="5" width="4">head嵌套</th><td>title</td><td>定义网页的标题<br></td></tr><tr><td>style</td><td>设置html元素的样式<br></td></tr><tr><td>script</td><td>定义网页使用哪种脚本语言<br></td></tr><tr><td>meta</td><td>定义网页元数据，如文档关键字、描述和作者信息<br></td></tr><tr><td>object</td><td>定义对象<br></td></tr><tr><td></td><td>body</td><td>包含显示在浏览器可视区的信息主体，及正文部分<br></td></tr></table>

<h2 id="标题标签-lt-h1-gt-lt-h6-gt"><a href="#标题标签-lt-h1-gt-lt-h6-gt" class="headerlink" title="标题标签&lt;h1&gt;~&lt;h6&gt;"></a>标题标签&lt;h1&gt;~&lt;h6&gt;</h2><table><br><tr><th>标签</th><th>示例<br></th></tr><tr><td>h1</td><td><h1>一级标题</h1><br></td></tr><tr><td>h1</td><td><h2>二级标题</h2><br></td></tr><tr><td>h3</td><td><h3>三级标题</h3><br></td></tr><tr><td>h4</td><td><h4>四级标题</h4><br></td></tr><tr><td>h5</td><td><h5>五级标题</h5><br></td></tr><tr><td>h6</td><td><h6>六级标题</h6><br></td></tr><tr><th>标题align属性</th><th>中间对齐方式<br></th></tr><tr><td>left</td><td>左对齐<br></td></tr><tr><td>right</td><td>右对齐<br></td></tr><tr><td>center</td><td>中间对齐<br></td></tr><tr><td>justify</td><td>两边对齐<br></td></tr></table>

<h2 id="段落标签-lt-p-gt"><a href="#段落标签-lt-p-gt" class="headerlink" title="段落标签&lt;p&gt;"></a>段落标签&lt;p&gt;</h2><table><br><tr><th>标签</th><th>描述<br></th></tr><tr><td>p</td><td>用于在网页中显示一个段落<br></td></tr><tr><td colspan="2">align属性对齐方式与&lt;h1&gt;方式一致<br></td></tr></table>

<h2 id="图形标签-lt-img-gt"><a href="#图形标签-lt-img-gt" class="headerlink" title="图形标签&lt;img&gt;"></a>图形标签&lt;img&gt;</h2><p>img是一个空元素，不需要结束元素,一般格式如下：</p>
<pre><code>&lt;img src=&quot;&quot; width=&quot;&quot; height=&quot;&quot; alt=&quot;&quot;&gt;
</code></pre><ol>
<li>src属性为img元素的必选属性，用于指定图形文件的路径，由URL确定，可以是本地资源，也可以是远程资源。</li>
<li>width和height属性分别表示图形显示在浏览器中的宽度和高度，为可选属性。</li>
<li>alt表示图片不能正常显示时的替换文字。</li>
<li>align属性<table><br><tr><th>align属性值</th><th>对齐方式<br></th></tr><tr><td>left</td><td>把图像和左边界对齐<br></td></tr><tr><td>right</td><td>把图像和右边界对齐<br></td></tr><tr><td>center</td><td>把图像居中<br></td></tr><tr><td>middle</td><td>把图像中部和行的中部对齐<br></td></tr><tr><td>top</td><td>把图像和同行中的最高部分对齐<br></td></tr><tr><td>bottom</td><td>把图像的底部和和同行文本的底部对齐<br></td></tr><tr><td>texttop</td><td>把图像和同行中的最高文本的顶部对齐<br></td></tr><tr><td>absmiddle</td><td>把图像中部和同行中最大顶的中部对齐<br></td></tr><tr><td>absbottom</td><td>把图像的底部和同行中的最大顶对齐<br></td></tr><tr><td>baseline</td><td>把图像的底部和文本的基线对齐<br></td></tr><tr><td colspan="2"><strong>通过设置align属性可以达到图文环绕的效果</strong><br></td></tr></table></li>
</ol>
<h2 id="一些常用标签"><a href="#一些常用标签" class="headerlink" title="一些常用标签"></a>一些常用标签</h2><table><br><tr><th>标签</th><th>描述<br></th></tr><tr><td>&lt;!–注释–&gt;</td><td>注释多行内容。<br>快捷方式：选中想注释掉的文本内容，按键盘Ctrl+/。<br></td></tr><tr><td>hr</td><td>在网页中画一条横线<br></td></tr><tr><td>br</td><td>另起一行<br></td></tr><tr><td>center</td><td>使内容居中显示<br></td></tr><tr><td>div</td><td>定义一个块级容器，用来规划网页<br></td></tr><tr><td>span</td><td>定义一个行内容器<br></td></tr></table>

<h2 id="制表标签"><a href="#制表标签" class="headerlink" title="制表标签"></a>制表标签</h2><table><br><tr><th>标签</th><th>描述<br></th></tr><tr><td>table</td><td>建立表格的主要元素。含border，bgcolor，bordercolor等属性。<br></td></tr><tr><td rowspan="2">caption</td><td>用于把一行文本置于表格上方或下方<br></td></tr><tr><td>&lt;caption align=”top/bottom”&gt;表格标题&lt;/caption&gt;<br></td></tr><tr><td>thead</td><td rowspan="3">分别定义表格的表头，表体和底部，书写顺序不影响其先后顺序。<br></td></tr><tr><td>tbody<br></td></tr><tr><td>tfoot<br></td></tr><tr><td>tr</td><td>定义表格中的一行。属性有align、bgcolor、border、bordercolor、nowrap（禁止浏览器对单元格中的内容产生换行）、valign（设置单元格内容在垂直方向的对齐方式：top、middle、bottom）<br></td></tr><tr><td>th</td><td>与td用法一致，但内容以粗体显示，可用来设计表格的表头。<br></td></tr><tr><td>td</td><td>定义一行中的一列，又叫单元格。具有colspan和rowspan属性，即一个单元格所占的列数和行数，可设置单元格合并;可设置宽高width、height，align等。<br></td></tr><tr><td rowspan="2">colgrop</td><td>设置某一列的width和bgcolor<br></td></tr><tr><td>&lt;colgrop&gt;&lt;col width=”” bgcolor=””&gt;&lt;colgrop&gt;<br></td></tr></table>

<h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><table><br><tr><td><th>标签</th><th>描述<br></th></td></tr><tr><td></td><td>form</td><td>建立表单的主要元素。含method属性（与服务器交换信息时使用的方式），一般选择post或<s>get</s><br></td></tr><tr><td></td><td>input</td><td>定义一个用于用户输入的表单控件。由type属性规定其类型；由name属性定义控件名称，按照name/value发送给服务器，没有写那么属性的控件不会发送。<br></td></tr><tr><td rowspan="10">input元素的type属性值</td><td>text</td><td>文本框<br></td></tr><tr><td>password</td><td>密码或口令<br></td></tr><tr><td>radio</td><td>单选按钮<br></td></tr><tr><td>checkbox</td><td>复选框，可选，可多选，可不选<br></td></tr><tr><td>file</td><td>文件按钮<br></td></tr><tr><td>hiddle</td><td>隐藏按钮<br></td></tr><tr><td>image</td><td>图像控件<br></td></tr><tr><td>button</td><td>命令按钮<br></td></tr><tr><td>submit</td><td>提交按钮，发送表单<br></td></tr><tr><td>reset</td><td>重置按钮，将表单填写清零<br></td></tr><tr><td rowspan="2"></td><td rowspan="2">select</td><td>下拉列表选择控件。通常包含若干个option元素。<br></td></tr><tr><td>默认multiple一次只能选择一项；设置multiple size=#，一次可选择#项（按住Ctrl或Shift键单击）<br></td></tr><tr><td></td><td>option</td><td>定义select元素的列表选项。属性：selected默认选中该项，disabled不能选择该项。<br></td></tr><tr><td></td><td>textarea</td><td>支持多行输入。属性：cols文本框宽度；rows文本框高度；或者使用width、height（准确）<br></td></tr></table>

<h2 id="框架标签"><a href="#框架标签" class="headerlink" title="框架标签"></a>框架标签</h2><table><br><tr><th>标签</th><th>描述<br></th></tr><tr><td rowspan="3">frameset</td><td>定义框架结构，放在body元素外。HTML5不支持。<br></td></tr><tr><td>用法：<br>&lt;frameset rows=”#,…,#”&gt;<br>&lt;frameset&gt;<br><br>&lt;frameset cols=”#,…,#”&gt;<br>&lt;frameset&gt;<br><br>＃的个数是将窗口所分区域数，#可以是整数，也可以是百分数。<br></td></tr><tr><td>frameborder属性值为‘0’隐藏边框，‘1’显示边框<br></td></tr><tr><td>frame</td><td>定义一个区域中的内容，HTML5不支持。<br></td></tr><tr><td>noframes</td><td>包含框架不能显示时的替换内容，HTML5不支持。<br></td></tr><tr><td>iframe</td><td>用法：&lt;iframe src=”” name=”name”&gt;<br></td></tr></table>

<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><table><br><tr><th>标签</th><th>描述<br></th></tr><tr><td>a</td><td>用法：&lt;a href=”” target=””&gt;链接对象&lt;a&gt;<br></td></tr><tr><td rowspan="5">href属性值</td><td>href属性用于指定超链接的链接对象，可以为相对地址或绝对地址。<br></td></tr><tr><td>http://或ftp://或gopher://等<br></td></tr><tr><td>mailto:…<br>提供一个E-mail地址，启动E-mail默认程序发送信件。<br></td></tr><tr><td>伪协议：javascript:;点击a时不做任何动作<br></td></tr><tr><td>锚点”#”；查询参数”？name=”。<br></td></tr><tr><td rowspan="5">target属性值</td><td>_blank<br>新打开一个浏览器窗口显示链接对象<br></td></tr><tr><td>_self<br>在原网页所在窗口打开<br></td></tr><tr><td>_top<br>在浏览器整个窗口（祖宗窗口）中显示<br></td></tr><tr><td>_parent<br>在父窗口中显示<br></td></tr><tr><td>框架name<br>在相应框架中显示<br></td></tr><tr><td>图片链接</td><td>&lt;a href=””&gt;&lt;img src=”” border=0&gt;&lt;a&gt;<br><br></td></tr></table>

<h2 id="字符控制"><a href="#字符控制" class="headerlink" title="字符控制"></a>字符控制</h2><table><br><tr><th>标签</th><th>描述<br></th></tr><tr><td rowspan="2">font</td><td>控制文字的字体、字号、颜色<br></td></tr><tr><td>用法：&lt;font face=”” size=”” color=””&gt;&lt;font&gt;<br></td></tr><tr><th colspan="2">字体样式标签<br></th></tr><tr><td>small</td><td>用小一号字体显示文字<br></td></tr><tr><td>strong</td><td>加粗显示<br></td></tr><tr><td>b</td><td>加粗显示<br></td></tr><tr><td>big</td><td>加大一号字体加粗显示<br></td></tr><tr><td>i</td><td>斜体强调显示<br></td></tr><tr><td>em</td><td>斜体强调显示<br></td></tr><tr><td>s</td><td>加上删除线<br></td></tr><tr><td>u</td><td>加上下划线<br></td></tr></table>

<h2 id="列表控制"><a href="#列表控制" class="headerlink" title="列表控制"></a>列表控制</h2><table><br><tr><th>标签</th><th>描述<br></th></tr><tr><td>dl</td><td>定义列表<br></td></tr><tr><td>dt</td><td>由dd元素定义的对象<br></td></tr><tr><td>dd</td><td>对dt元素的定义<br></td></tr><tr><td>menu</td><td>设定菜单或列表的开头<br></td></tr><tr><td>ul</td><td>无序列表<br></td></tr><tr><td>ol</td><td>有序列表<br></td></tr><tr><td>li</td><td>列表项目<br></td></tr><tr><th colspan="2">ul、ol元素的type属性<br></th></tr><tr><td>1</td><td>以整数作为项目标记符<br></td></tr><tr><td>a</td><td>以小写字母作为项目标记符<br></td></tr><tr><td>A</td><td>以大写字母作为项目标记符<br></td></tr><tr><td>i</td><td>以小写罗马数字作为项目标记符<br></td></tr><tr><td>I</td><td>以大写罗马数字作为项目标记符<br></td></tr><tr><td>circle</td><td>以空心圆作为项目标记符<br></td></tr><tr><td>disc</td><td>以实心圆作为项目标记符<br></td></tr><tr><td>square</td><td>以方块作为项目标记符<br></td></tr></table>

<h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><table><br><tr><th>技术</th><th>实现方法<br></th></tr><tr><td>声音与视频</td><td>使用a标签<br></td></tr><tr><td>背景音乐</td><td>在head标签中写入：<br>&lt;bgsound src=”” loop=””&gt;<br>（loop为循环次数）(IE元素，非标准)<br></td></tr><tr><td>音频</td><td>使用audio、object、embed<br></td></tr><tr><td>动态文件</td><td>使用img元素的dynsrc（引入各种格式的多媒体）、loop、start（值为mouseover等）等IE属性。<br></td></tr><tr><td>动画和视频的插入</td><td>使用embed元素，用法：<br>&lt;embed src=”” width=”” height=””&gt;<br></td></tr><tr><td>文本滚动</td><td>使用&lt;marquee&gt;元素，内含width、height、bgcolor、border、behavior（=slide、sroll、alternate等）、direction、loop等属性。<br></td></tr></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/09/HTML常用标签/" data-id="cjmlkb38h0004hs7lq30myx60" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（H）html-常用标签/">（H）html-常用标签</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTML5标签" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/29/HTML5标签/" class="article-date">
  <time datetime="2018-04-29T11:35:35.000Z" itemprop="datePublished">2018-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/29/HTML5标签/">HTML5标签列表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="以下为所有标准化的、有效的HTML5元素。"><a href="#以下为所有标准化的、有效的HTML5元素。" class="headerlink" title="以下为所有标准化的、有效的HTML5元素。"></a>以下为所有标准化的、有效的HTML5元素。</h5><h2 id="根元素"><a href="#根元素" class="headerlink" title="根元素"></a>根元素</h2><table><br><tr><br><th>Element<br></th><th>Description<br></th></tr><tr><br><td>&lt;html&gt;<br></td><td>代表 HTML 或 XHTML 文档的根。其他所有元素必须是这个元素的子节点。<br></td></tr></table>

<h2 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h2><table><br><tr><br><th>Element<br></th><th>Description<br></th></tr><tr><br><td>&lt;head&gt;<br></td><td>代表关于文档元数据的一个集合，包括脚本或样式表的链接或内容。<br></td></tr><tr><br><td>&lt;title&gt;<br></td><td>代表关于文档元数据的一个集合，包括脚本或样式表的链接或内容。<br></td></tr><tr><br><td>&lt;base&gt;<br></td><td>定义页面上相对 URL 的基准 URL。<br></td></tr><tr><br><td>&lt;link&gt;<br></td><td>用于链接外部的 CSS 到该文档。<br></td></tr><tr><br><td>&lt;meta&gt;<br></td><td>定义其他HTML元素无法描述的元数据。<br></td></tr><tr><br><td>&lt;style&gt;<br></td><td>用于内联CSS。<br></td></tr></table>

<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><table><br><tr><br><th>Element<br></th><th>Description<br></th></tr><tr><br><td>&lt;script&gt;<br></td><td>定义一个内联脚本或链接到外部脚本。脚本语言是 JavaScript。<br></td></tr><tr><br><td>&lt;noscript&gt;<br></td><td>定义当浏览器不支持脚本时显示的替代文字。<br></td></tr><tr><br><td>&lt;template&gt;<br></td><td>通过JS在运行时实例化内容的容器。<br></td></tr></table>

<h2 id="章节"><a href="#章节" class="headerlink" title="章节"></a>章节</h2><table><br><tr><br><th>Element<br></th><th>Description<br></th></tr><tr><br><td>&lt;body&gt;<br></td><td>代表 HTML 文档的内容。在文档中只能有一个 &lt;body&gt; 元素。<br></td></tr><tr><br><td>&lt;section&gt;<br></td><td>定义文档中的一个章节。<br></td></tr><tr><br><td>&lt;nav&gt;<br></td><td>定义只包含导航链接的章节。<br></td></tr><tr><br><td>&lt;article&gt;<br></td><td>定义可以独立于其余内容的完整独立内容块。<br></td></tr><tr><br><td>&lt;aside&gt;<br></td><td>定义和页面内容关联度较低的内——如果被删除，剩下的内容依然很合理。<br></td></tr><tr><br><td>&lt;h1&gt;&lt;h2&gt;&lt;h3&gt;<br>&lt;h4&gt;&lt;h5&gt;&lt;h6&gt;<br></td><td>标题元素实现了六层文档标题，&lt;h1&gt; 是最大的标题，&lt;h6&gt; 是最小的标题。标题元素简要地描述章节的主题。<br></td></tr><tr><br><td>&lt;header&gt;<br></td><td>定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录。<br></td></tr><tr><br><td>&lt;footer&gt;<br></td><td>定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。<br></td></tr><tr><br><td>&lt;address&gt;<br></td><td>定义包含联系信息的一个章节。<br></td></tr><tr><br><td>&lt;main&gt;<br></td><td>定义文档中主要或重要内容。<br></td></tr></table>

<h2 id="组织内容"><a href="#组织内容" class="headerlink" title="组织内容"></a>组织内容</h2><table><br><tr><br><th>Element<br></th><th>Description<br></th></tr><tr><br><td>&lt;p&gt;<br></td><td>定义一个段落。<br></td></tr><tr><br><td>&lt;hr&gt;<br></td><td>代表章节、文章或其他长内容中段落之间的分隔符。<br></td></tr><tr><br><td>&lt;pre&gt;<br></td><td>代表其内容已经预先排版过，格式应当保留 。<br></td></tr><tr><br><td>&lt;blockquote&gt;<br></td><td>代表引用自其他来源的内容。<br></td></tr><tr><br><td>&lt;ol&gt;<br></td><td>定义一个有序列表。<br></td></tr><tr><br><td>&lt;ul&gt;<br></td><td>定义一个无序列表。<br></td></tr><tr><br><td>&lt;li&gt;<br></td><td>定义列表中的一个列表项。<br></td></tr><tr><br><td>&lt;dl&gt;<br></td><td>代表一个定义列表（一系列术语及其定义）。<br></td></tr><tr><br><td>&lt;dt&gt;<br></td><td>代表由下一个&lt;dd&gt;定义的术语。<br></td></tr><tr><br><td>&lt;dd&gt;<br></td><td>对上个术语的定义。<br></td></tr><tr><br><td>&lt;figure&gt;<br></td><td>代表一个和文档有关的图例。<br></td></tr><tr><br><td>&lt;figcaption&gt;<br></td><td>代表一个图例的说明。<br></td></tr><tr><br><td>&lt;div&gt;<br></td><td>代表一个通用容器，没有任何实际含义。<br></td></tr></table>

<h2 id="文字形式"><a href="#文字形式" class="headerlink" title="文字形式"></a>文字形式</h2><table><br><tr><br><th>Element<br></th><th>Description<br></th></tr><tr><br><td>&lt;a&gt;<br></td><td>代表一个链接到其他资源的超链接。<br></td></tr><tr><br><td>&lt;em&gt;<br></td><td>代表强调文字。<br></td></tr><tr><br><td>&lt;strong&gt;<br></td><td>代表特别重要 文字。<br></td></tr><tr><br><td>&lt;amsll&gt;<br></td><td>代表注释 ，如免责声明、版权声明等，对理解文档不重要。<br></td></tr><tr><br><td>&lt;s&gt;<br></td><td>代表不准确或不相关 的内容。<br></td></tr><tr><br><td>&lt;cite&gt;<br></td><td>代表作品标题 。<br></td></tr><tr><br><td>&lt;q&gt;<br></td><td>代表内联的引用 。<br></td></tr><tr><br><td>&lt;dfn&gt;<br></td><td>代表一个术语包含在其最近祖先内容中的定义 。<br></td></tr><tr><br><td>&lt;abbr&gt;<br></td><td>代表省略或缩写 ，其完整内容在 title 属性中。<br></td></tr><tr><br><td>&lt;data&gt;<br></td><td>关联一个内容的机器可读的等价形式 （该元素只在 WHATWG 版本的 HTML 标准中，不在 W3C 版本的 HTML5 标准中）。<br></td></tr><tr><br><td>&lt;time&gt;<br></td><td>代表日期和时间值；机器可读的等价形式通过 datetime 属性指定。<br></td></tr><tr><br><td>&lt;code&gt;<br></td><td>代表计算机代码。<br></td></tr><tr><br><td>&lt;var&gt;<br></td><td>代表代码中的变量。<br></td></tr><tr><br><td>&lt;samp&gt;<br></td><td>代表程序或电脑的输出。<br></td></tr><tr><br><td>&lt;kbd&gt;<br></td><td>代表用户输入，一般从键盘输出，但也可以代表其他输入，如语音输入。<br></td></tr><tr><br><td>&lt;sup&gt;<br></td><td>代表上标。<br></td></tr><tr><br><td>&lt;sub&gt;<br></td><td>代表下标。<br></td></tr><tr><br><td>&lt;i&gt;<br></td><td>代表一段不同性质的文字，如技术术语、外文短语等。<br></td></tr><tr><br><td>&lt;b&gt;<br></td><td>代表一段需要被关注 的文字。<br></td></tr><tr><br><td>&lt;u&gt;<br></td><td>代表一段需要下划线呈现的文本注释，如标记出拼写错误的文字等。<br></td></tr><tr><br><td>&lt;mark&gt;<br></td><td>代表一段需要被高亮的引用文字。<br></td></tr><tr><br><td>&lt;ruby&gt;<br></td><td>代表被ruby 注释标记的文本，如中文汉字和它的拼音。<br></td></tr><tr><br><td>&lt;rt&gt;<br></td><td>代表ruby注释，如中文拼音。<br></td></tr><tr><br><td>&lt;rp&gt;<br></td><td>代表 ruby 注释两边的额外插入文本 ，用于在不支持 ruby 注释显示的浏览器中提供友好的注释显示。<br></td></tr><tr><br><td>&lt;bdi&gt;<br></td><td>代表需要脱离 父元素文本方向的一段文本。它允许嵌入一段不同或未知文本方向格式的文本。<br></td></tr><tr><br><td>&lt;bdo&gt;<br></td><td>指定子元素的文本方向，显示地覆盖默认的文本方向。<br></td></tr><tr><br><td>&lt;span&gt;<br></td><td>代表一段没有特殊含义的文本。当其他语义元素都不适合文本时候可以使用该元素。<br></td></tr><tr><br><td>&lt;br&gt;<br></td><td>换行。<br></td></tr><tr><br><td>&lt;wbr<br></td><td>建议换行 (Word Break Opportunity) ，当文本太长需要换行时将会在此处添加换行符。<br></td></tr></table>

<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><table><br><tr><br><th>Element<br></th><th>Description<br></th></tr><tr><br><td>&lt;ins&gt;<br></td><td>定义增加到文档的内容。<br></td></tr><tr><br><td>&lt;del&gt;<br></td><td>定义从文档中删除的内容。<br></td></tr></table>

<h2 id="嵌入内容"><a href="#嵌入内容" class="headerlink" title="嵌入内容"></a>嵌入内容</h2><table><br><tr><br><th>Element<br></th><th>Description<br></th></tr><tr><br><td>&lt;img&gt;<br></td><td>代表一张图片 。<br></td></tr><tr><br><td>&lt;iframe&gt;<br></td><td>代表一个内联的框架 。<br></td></tr><tr><br><td>&lt;embed&gt;<br></td><td>代表一个嵌入 的外部资源，如应用程序或交互内容。<br></td></tr><tr><br><td>&lt;object&gt;<br></td><td>代表一个外部资源 ，如图片、HTML 子文档、插件等。<br></td></tr><tr><br><td>&lt;param&gt;<br></td><td>代表 <object> 元素所指定的插件的参数 。<br><tr><br><td>&lt;video&gt;<br></td><td>代表一段视频 及其视频文件和字幕，并提供了播放视频的用户界面。<br></td></tr><tr><br><td>&lt;audio&gt;<br></td><td>代表一段声音 ，或音频流 。<br></td></tr><tr><br><td>&lt;source&gt;<br></td><td>为 &lt;video&gt; 或 &lt;audio&gt; 这类媒体元素指定媒体源 。<br></td></tr><tr><br><td>&lt;track&gt;<br></td><td>为 &lt;video&gt; 或 &lt;audio&gt; 这类媒体元素指定文本轨道（字幕） 。<br></td></tr><tr><br><td>&lt;canvas&gt;<br></td><td>代表位图区域 ，可以通过脚本在它上面实时呈现图形，如图表、游戏绘图等。<br></td></tr><tr><br><td>&lt;map&gt;<br></td><td>与&lt;area&gt; 元素共同定义图像映射 区域。<br></td></tr><tr><br><td>&lt;area&gt;<br></td><td>与&lt;map&gt; 元素共同定义图像映射 区域。<br></td></tr><tr><br><td>&lt;svg&gt;<br></td><td>定义一个嵌入式矢量图 。<br></td></tr><tr><br><td>&lt;math&gt;<br></td><td>定义一段数学公式 。<br></td></tr></object></td></tr></table>

<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><br><tr><br><th>Element<br></th><th>Description<br></th></tr><tr><br><td>&lt;table&gt;<br></td><td>定义多维数据 。<br></td></tr><tr><br><td>&lt;caption&gt;<br></td><td>代表表格的标题 。<br></td></tr><tr><br><td>&lt;colgroup&gt;<br></td><td>代表表格中一组单列或多列 。<br></td></tr><tr><br><td>&lt;col&gt;<br></td><td>代表表格中的列 。<br></td></tr><tr><br><td>&lt;tbody&gt;<br></td><td>代表表格中一块具体数据 （表格主体）。<br></td></tr><tr><br><td>&lt;thead&gt;<br></td><td>代表表格中一块列标签 （表头）。<br></td></tr><tr><br><td>&lt;tfoot&gt;<br></td><td>代表表格中一块列摘要 （表尾）。<br></td></tr><tr><br><td>&lt;tr&gt;<br></td><td>代表表格中的行 。<br></td></tr><tr><br><td>&lt;td&gt;<br></td><td>代表表格中的单元格 。<br></td></tr><tr><br><td>&lt;th&gt;<br></td><td>代表表格中的头部单元格 。<br></td></tr></table>

<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><table><br><tr><br><th>Element<br></th><th>Description<br></th></tr><tr><br><td>&lt;form&gt;<br></td><td>代表一个表单，由控件组成。<br></td></tr><tr><br><td>&lt;fieldset&gt;<br></td><td>代表控件组。<br></td></tr><tr><br><td>&lt;legend&gt;<br></td><td>代表&lt;fieldset&gt;控件组的标题。<br></td></tr><tr><br><td>&lt;label&gt;<br></td><td>代表表单控件的标题。<br></td></tr><tr><br><td>&lt;input&gt;<br></td><td>代表允许用户编辑数据的数据区（文本框、单选框、复选框等）。<br></td></tr><tr><br><td>&lt;button&gt;<br></td><td>代表按钮。<br></td></tr><tr><br><td>&lt;select&gt;<br></td><td>代表下拉框。<br></td></tr><tr><br><td>&lt;datalist&gt;<br></td><td>提供给其他控件的一组预定义选项。<br></td></tr><tr><br><td>&lt;optgroup&gt;<br></td><td>代表一个选项分组。<br></td></tr><tr><br><td>&lt;option&gt;<br></td><td>代表一个&lt;select&gt;元素或&lt;datalist&gt;元素中的一个选项。<br></td></tr><tr><br><td>&lt;textarea&gt;<br></td><td>多欧行文本框。<br></td></tr><tr><br><td>&lt;keygen&gt;<br></td><td>密钥对生成器控件。<br></td></tr><tr><br><td>&lt;output&gt;<br></td><td>计算值。<br></td></tr><tr><br><td>&lt;progress&gt;<br></td><td>代表进度条。<br></td></tr><tr><br><td>&lt;meter&gt;<br></td><td>代表滑动条。<br></td></tr></table>

<h2 id="交互元素"><a href="#交互元素" class="headerlink" title="交互元素"></a>交互元素</h2><table><br><tr><br><th>Element<br></th><th>Description<br></th></tr><tr><br><td>&lt;details&gt;<br></td><td>用户可以获取额外信息或空间的小部件。<br></td></tr><tr><br><td>&lt;summary&gt;<br></td><td>代表&lt;details&gt;元素的综述或标题。<br></td></tr><tr><br><td>&lt;menuitem&gt;<br></td><td>用户可以点击的菜单项。<br></td></tr><tr><br><td>&lt;menu<br></td><td>代表菜单。<br></td></tr></table>

<h4 id="MDN原文"><a href="#MDN原文" class="headerlink" title="MDN原文"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5/HTML5_element_list" target="_blank" rel="noopener">MDN原文</a></h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/29/HTML5标签/" data-id="cjmlkb38e0003hs7lydeswa3d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（H）html5-标签/">（H）html5-标签</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/（C）css布局/">（C）css布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（C）flex布局/">（C）flex布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（C）垂直居中/">（C）垂直居中</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（G）git入门/">（G）git入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（H）canvas的使用/">（H）canvas的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（H）html-常用标签/">（H）html-常用标签</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（H）html5-标签/">（H）html5-标签</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）JS-数据类型/">（J）JS-数据类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）JS-数据结构/">（J）JS-数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）JS中-this指向/">（J）JS中-this指向</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）JS函数及new/">（J）JS函数及new</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）Promise/">（J）Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）原型与原型链/">（J）原型与原型链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）自己实现-jQuery-API/">（J）自己实现-jQuery API</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（M）命令行基本命令/">（M）命令行基本命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（S）快速排序-js/">（S）快速排序-js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（S）排序算法-js/">（S）排序算法-js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）HTTP（入门）/">（W）HTTP（入门）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）Session/">（W）Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）Web-Storage/">（W）Web Storage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）ajax/">（W）ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）jsonp/">（W）jsonp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）登录注册、cookie/">（W）登录注册、cookie</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/（C）css布局/" style="font-size: 10px;">（C）css布局</a> <a href="/tags/（C）flex布局/" style="font-size: 10px;">（C）flex布局</a> <a href="/tags/（C）垂直居中/" style="font-size: 10px;">（C）垂直居中</a> <a href="/tags/（G）git入门/" style="font-size: 10px;">（G）git入门</a> <a href="/tags/（H）canvas的使用/" style="font-size: 10px;">（H）canvas的使用</a> <a href="/tags/（H）html-常用标签/" style="font-size: 10px;">（H）html-常用标签</a> <a href="/tags/（H）html5-标签/" style="font-size: 10px;">（H）html5-标签</a> <a href="/tags/（J）JS-数据类型/" style="font-size: 10px;">（J）JS-数据类型</a> <a href="/tags/（J）JS-数据结构/" style="font-size: 10px;">（J）JS-数据结构</a> <a href="/tags/（J）JS中-this指向/" style="font-size: 10px;">（J）JS中-this指向</a> <a href="/tags/（J）JS函数及new/" style="font-size: 10px;">（J）JS函数及new</a> <a href="/tags/（J）Promise/" style="font-size: 10px;">（J）Promise</a> <a href="/tags/（J）原型与原型链/" style="font-size: 10px;">（J）原型与原型链</a> <a href="/tags/（J）自己实现-jQuery-API/" style="font-size: 10px;">（J）自己实现-jQuery API</a> <a href="/tags/（M）命令行基本命令/" style="font-size: 10px;">（M）命令行基本命令</a> <a href="/tags/（S）快速排序-js/" style="font-size: 10px;">（S）快速排序-js</a> <a href="/tags/（S）排序算法-js/" style="font-size: 10px;">（S）排序算法-js</a> <a href="/tags/（W）HTTP（入门）/" style="font-size: 10px;">（W）HTTP（入门）</a> <a href="/tags/（W）Session/" style="font-size: 10px;">（W）Session</a> <a href="/tags/（W）Web-Storage/" style="font-size: 10px;">（W）Web Storage</a> <a href="/tags/（W）ajax/" style="font-size: 10px;">（W）ajax</a> <a href="/tags/（W）jsonp/" style="font-size: 10px;">（W）jsonp</a> <a href="/tags/（W）登录注册、cookie/" style="font-size: 10px;">（W）登录注册、cookie</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/09/28/JS普通函数与构造函数与new/">JS普通函数与构造函数与new</a>
          </li>
        
          <li>
            <a href="/2018/09/28/JS中的this指向/">JS中的this指向</a>
          </li>
        
          <li>
            <a href="/2018/09/24/总结垂直居中/">垂直居中总结</a>
          </li>
        
          <li>
            <a href="/2018/09/23/正确快速排序学习/">快速排序（正确版）</a>
          </li>
        
          <li>
            <a href="/2018/09/21/flex布局总结/">flex布局总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 lxiaox<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>