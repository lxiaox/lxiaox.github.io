<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>lxiaox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="lxiaox">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="lxiaox">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lxiaox">
  
    <link rel="alternate" href="/atom.xml" title="lxiaox" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lxiaox</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Promise学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/07/Promise学习/" class="article-date">
  <time datetime="2018-09-07T11:40:44.000Z" itemprop="datePublished">2018-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/07/Promise学习/">Promise学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是-Promise？"><a href="#什么是-Promise？" class="headerlink" title="什么是 Promise？"></a>什么是 Promise？</h1><p>Promise作为ES6最重要的特性之一，它本身是一个构造函数，并拥有<code>resolve</code>、 <code>reject</code>、 <code>all</code>、 <code>race</code> 等方法。</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31gy1fx9r9ru3ttj20lf06wq3e.jpg" alt="打印Promise"></p>
<h5 id="Promise-对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。"><a href="#Promise-对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。" class="headerlink" title="Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。"></a>Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。</h5><h3 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h3><p><code>new Promimse( function(resolve, reject) {} )</code></p>
<p>Promise构造函数接受一个函数，这个函数的参数为<code>resolve</code>和<code>reject</code>，<code>resolve</code>将<code>Promise</code>状态改为<code>fulfilled</code>,<code>reject</code>将其状态改为<code>rejected</code>，promise会根据不同状态执行不同操作。</p>
<h3 id="一个Promise有以下几种状态："><a href="#一个Promise有以下几种状态：" class="headerlink" title="一个Promise有以下几种状态："></a>一个Promise有以下几种状态：</h3><ul>
<li><code>pending</code>：初始状态，不成功也没失败</li>
<li><code>fulfilled</code>：表示操作成功完成</li>
<li><code>rejected</code>：表示操作失败</li>
<li><code>settled</code>：完成状态，fulfilled和rejected的统称</li>
</ul>
<p><code>pending</code>状态的Promise可能触发<code>fulfilled</code>状态，并传递一个值给成功之后的操作；也可能触发<code>rejected</code>状态，并传递失败信息或失败原因给失败之后的操作。</p>
<h1 id="改变状态之后的操作："><a href="#改变状态之后的操作：" class="headerlink" title="改变状态之后的操作："></a>改变状态之后的操作：</h1><p>打印Promise对象可以看到，它的原型方法<code>then()</code>、<code>catch()</code>、<code>finally()</code>，这些方法会表明Promise操作完成之后要做的事情。</p>
<h3 id="1、Promise-prototype-then-onFulfilled-onRejected"><a href="#1、Promise-prototype-then-onFulfilled-onRejected" class="headerlink" title="1、Promise.prototype.then(onFulfilled, onRejected)"></a>1、Promise.prototype.then(onFulfilled, onRejected)</h3><p> then()方法最多接受两个参数，即成功之后调用的回调函数，和失败之后调用的回调函数，同时它返回一个Promise对象，使得Promise().then().then()这样的链式操作得以实现。</p>
<pre><code>promise.then(
    function(value){
        //如果成功...
    },
    function(reason){
        //失败...
    }
)
</code></pre><p><code>then()</code>方法也可只接受成功的回调函数，那么失败情况就会由<code>catch()</code>方法处理。</p>
<h3 id="2、Promise-prototype-catch-onRejected"><a href="#2、Promise-prototype-catch-onRejected" class="headerlink" title="2、Promise.prototype.catch(onRejected)"></a>2、Promise.prototype.catch(onRejected)</h3><p> <code>catch()</code>方法处理拒绝也就是失败的情况，同时返回一个Promise对象。</p>
<pre><code>promise.catch(
    function(reason){
        //失败...
    }
)
</code></pre><h3 id="3、Promise-prototype-finally"><a href="#3、Promise-prototype-finally" class="headerlink" title="3、Promise.prototype.finally()"></a>3、Promise.prototype.finally()</h3><p> <code>finall()</code>也返回一个Promise对象，then()和catch()执行之后都会执行finally()，可以避免重复书写同样的代码。</p>
<pre><code>promise.finally(
    function(){
        //成功和失败都会执行...
    }
)
</code></pre><p>要注意，就算是失败的Promise经过<code>then()</code>、<code>catch()</code>处理，返回的新的Promise状态是<strong>成功</strong>的，除非再次处理（<code>then</code>、<code>catch</code>）失败。</p>
<p>同时形如<code>promise.then().then().then().catch()</code>，所有的失败情况都由最后的<code>catch()</code>处理，一旦某个地方失败，就会顺着操作链寻找到失败的回调函数。</p>
<h2 id="那么现在就可以写一个Promise了"><a href="#那么现在就可以写一个Promise了" class="headerlink" title="那么现在就可以写一个Promise了"></a>那么现在就可以写一个Promise了</h2><p>先封装一个函数：</p>
<pre><code>function test(num){
    var p = new Promise(function(resolve, reject){
        //设置延时，进行异步操作
        setTimeout(function(){
           if(num === 66){
               console.log(&apos;顺利完成&apos;)
               resolve(&apos;66大顺，成功&apos;) //resolve将状态改为fulfilled，完成
           }else{
               console.log(&apos;失败&apos;)
               reject(&apos;不顺利，失败了&apos;)  //reject将状态改为rejected，拒绝
           }
        }, 3000)
    })
    return p
}
</code></pre><p>在上述代码中，我们封装了一个函数，这个函数返回一个promise对象。我们定义了一个异步操作，就是判断数值是否为66，等于成功，不等于就失败。</p>
<p>为什么要封装函数？因为在new一个Promise对象时，传进去的函数会执行，封装函数之后我们就可以在调用函数时再执行它。</p>
<p>接下来就可以调用函数，进行下一步操作：</p>
<pre><code>//成功的情况：
test(66).then(function(value){
    console.log(&apos;成功信息：&apos;)
    console.log(value)
}).catch(function(reason){
    console.log(&apos;失败信息：&apos;)
    console.log(reason)
})
</code></pre><p>成功结果截图，3s之后输出：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31gy1fx9rak3q9zj20ao055glo.jpg" alt="成功结果"></p>
<pre><code>//失败的情况：
test(55).then(function(value){
    console.log(&apos;成功信息：&apos;)
    console.log(value)
}).catch(function(reason){
    console.log(&apos;失败信息：&apos;)
    console.log(reason)
})
</code></pre><p>失败结果截图，3s之后输出：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31gy1fx9rbg8axej2099056mx7.jpg" alt="失败结果"></p>
<h1 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h1><h3 id="1、Promise-resolve-value"><a href="#1、Promise-resolve-value" class="headerlink" title="1、Promise.resolve(value)"></a>1、Promise.resolve(value)</h3><p><code>resolve()</code>方法返回一个给定值解析之后的Promise对象。其中又分为几种情况：</p>
<p>1、如果传入的值本身是一个Promise对象，那么就返回这个Promise对象</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31gy1fx9rbtn88vj209704xglm.jpg" alt="传入Promise对象"></p>
<p>如图传入Promise对象为：test(55)，它的状态是失败，resolve()的返回值就是这个失败状态的promise，因此会调用失败的回调输出failed。</p>
<p>2、如果传入的值是个thenable对象，即带有then方法，那么返回的是then之后最终状态的promise。</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31gy1fx9rcfj5n0j20cm08faac.jpg" alt="传入thenable"></p>
<p>如图传入<code>test(55).then().catch()</code>，虽然<code>test(55)</code>是失败的，但是它经过<code>catch()</code>处理，最后返回的状态是成功，所以<code>resolve()</code>最后的<code>then()</code>会输出<code>success</code>。</p>
<p>3、如果传入的是其他值，那么就以成功状态返回Promise。</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9rcpxasij209l05f0ss.jpg" alt="传入其他值"></p>
<p>如图传入<code>‘abcde’</code>，最终状态是成功，输出<code>success</code>。</p>
<h3 id="2、Promise-reject-reason"><a href="#2、Promise-reject-reason" class="headerlink" title="2、Promise.reject(reason)"></a>2、Promise.reject(reason)</h3><p><code>reject()</code>方法返回一个带有拒绝原因参数的Promise对象。</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9rcyvui3j209s04kq2y.jpg" alt="reject1"></p>
<p>从上图可以看出这里的拒绝原因就是字符串‘abcde’本身。</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9rdega12j20bf04twek.jpg" alt="reject2"></p>
<p>这里的原因是Error: failed。</p>
<h3 id="3、Promise-all-iterable"><a href="#3、Promise-all-iterable" class="headerlink" title="3、Promise.all(iterable)"></a>3、Promise.all(iterable)</h3><p><code>all()</code>方法返回一个Pomise对象，它传入的参数（iterable译为可迭代的）是promise的数组，即多个promise，只有所有的Promise对象都为成功状态，<code>all()</code>才会返回成功状态的Promise对象。如果有一个失败，那么<code>all()</code>返回失败promise，且失败原因就是第一个失败promise的失败原因。</p>
<pre><code>var promise1 = Promise.resolve(66)
var promise2 = Promise.reject(55)
var promise3 = &apos;abcde&apos;
var promise4 = new Promise(function(resolve, reject) {
    setTimeout(()=&gt;{resolve(&apos;success&apos;)}, 300)
})
var promise5 = new Promise(function(resolve, reject) {
    setTimeout(()=&gt;{reject(&apos;failed&apos;)}, 300)
})
//promise4和promise5被创建的时候，传入的函数就开始执行，我验证时是直接在控制台粘贴本段所有代码再执行，影响不大，但最好封装成一个函数，将时间延迟增长至3s:
var promise4 =function() {
    return new Promise(function (resolve, reject) {
        setTimeout(() =&gt; {
            resolve(&apos;success&apos;)
        }, 3000)
    })
}
var promise5 =function() {
    return new Promise(function (resolve, reject) {
        setTimeout(() =&gt; {
            reject(&apos;failed&apos;)
        }, 3000)
    })
}

function onFulfilled(value) {
    console.log(&apos;成功：&apos;)
    console.log(value)
}
function onRejected(reason){
    console.log(&apos;失败：&apos; + reason)
}

//开始测试：
Promise.all([promise1, promise2, promise3]).then(onFulfilled,onRejected)
    //输出“失败：55”，因为promise1成功，promise2失败

Promise.all([promise5(), promise2, promise3]).then(onFulfilled,onRejected)
    //输出“失败：55”，因为promise2比promise5先处理完成，这里是看处理时间
    //promise5设置了延时，这里要注意本人之前犯的错误：setTimeout(resolve(&apos;success&apos;),300)
    //resolve(&apos;success&apos;)没有包在函数里，导致代码直接执行（原因同eval()）没有延迟，最终输出为“失败：failed”，得出错误的结论

Promise.all([promise1, promise3, promise4()]).then(onFulfilled,onRejected)
    //过3s输出：Array [66, &quot;abcde&quot;, &quot;success&quot;]，因为promise4有延时，等全部promise为成功状态时就会将值组成数组一起输出
</code></pre><h3 id="3、Promise-race-iterable"><a href="#3、Promise-race-iterable" class="headerlink" title="3、Promise.race(iterable)"></a>3、Promise.race(iterable)</h3><p><code>race()</code>方法返回一个Promise对象，它与<code>all()</code>不同之处在于一旦迭代器中某个proise完成或拒绝，那么就返回完成或拒绝的Promise对象。</p>
<pre><code>//沿用上面的代码
Promise.race([promise1, promise2, promise3])
    .then(onFulfilled,onRejected)
//输出“成功：66”，第一个成功就返回成功值66。

Promise.race([promise5(), promise2, promise3])
    .then(onFulfilled,onRejected)
//输出“失败：55”，因为promise5有延时，所以promise2最先处理完。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/07/Promise学习/" data-id="cju6g672q000m1o7ls6sbbfe7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（J）Promise/">（J）Promise</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-canvas的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/01/canvas的使用/" class="article-date">
  <time datetime="2018-09-01T06:11:49.000Z" itemprop="datePublished">2018-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/01/canvas的使用/">canvas的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、canvas的作用"><a href="#一、canvas的作用" class="headerlink" title="一、canvas的作用"></a>一、canvas的作用</h2><p>canvas是一个HTML元素，可以使用脚本（如JS）绘制图形，制作照片，动画，甚至实时视频处理渲染。</p>
<h2 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h2><p>canvas和img元素很像，但是没有src和alt属性，只有width和height两个属性（默认300px，150px）</p>
<h2 id="三、替代内容"><a href="#三、替代内容" class="headerlink" title="三、替代内容"></a>三、替代内容</h2><p>跟audio/vedio等标签很像，直接将替代内容写在标签里面。比较老的不支持canvas的浏览器会展示替代内容，支持的会忽略替代内容。</p>
<pre><code>&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;  
    //这里写替代内容，文字或图片等等。
&lt;/canvas&gt;
</code></pre><h2 id="四、标签不可省"><a href="#四、标签不可省" class="headerlink" title="四、标签不可省"></a>四、标签不可省</h2><p>不同于img标签，canvas需要闭合。</p>
<p><code>&lt;/canvas&gt;结束标签</code>没有时，后面的内容都将作为替代内容。</p>
<h2 id="五、JS使用"><a href="#五、JS使用" class="headerlink" title="五、JS使用"></a>五、JS使用</h2><p>canvas创造了一块空白大小的空白画布（渲染上下文（名词）），它有一个 getContext()方法，可以获取到渲染上下文和绘画功能，它有一个参数，比如2D图形：</p>
<pre><code>var canvas = document.getElementById(&apos;canvas&apos;)
var ctx = canvas.getContext(&apos;2d&apos;)
//or
var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;)
</code></pre><p>也可以检查浏览器是否支持canvas，代码改为</p>
<pre><code>if (canvas.getContext){
      var ctx = canvas.getContext(&apos;2d&apos;);
}else{}
</code></pre><h2 id="六、绘制图形"><a href="#六、绘制图形" class="headerlink" title="六、绘制图形"></a>六、绘制图形</h2><p>首先要了解：如[100px*100px]的canvas画布的坐标空间，在左上角坐标为(0,0)，向右延申为x轴，向下为y轴，右下角坐标为(100,100)。</p>
<h3 id="1、三个画矩形的方法"><a href="#1、三个画矩形的方法" class="headerlink" title="1、三个画矩形的方法"></a>1、三个画矩形的方法</h3><ol>
<li>fillRect(x,y,width,height): 实心矩形。</li>
<li>strokeRect(x,y,width,height)：空心矩形，即矩形边框。</li>
<li>clearRect(x,y,width,height)：清除该矩形区域。</li>
</ol>
<h3 id="2、路径-画线"><a href="#2、路径-画线" class="headerlink" title="2、路径/画线"></a>2、路径/画线</h3><ol>
<li>beginPath()：新建一条路径</li>
<li>closePath()：关闭一条路径（非必需），（将笔触从当前移动到起始位置，可能会画一条直线）</li>
<li>fill()：填充路径内容（会自动关闭路径）</li>
<li>stroke()：路径描边</li>
<li>moveTo(x,y)：移动笔触</li>
<li>lineTo(x,y)：从当前位置画线到(x,y)</li>
</ol>
<p>code:</p>
<pre><code>//画一个三角形
ctx.beginPath()
ctx.moveTo(100,100)
ctx.lineTo(150,50)
ctx.lineTo(150,150)
ctx.fill()    //不写fill或stroke不会显示东西

//不管画什么都要写ctx.fill()/stroke()
//不管画什么都要写ctx.fill()/stroke()
//不管画什么都要写ctx.fill()/stroke()
</code></pre><h3 id="3、圆-圆弧"><a href="#3、圆-圆弧" class="headerlink" title="3、圆/圆弧"></a>3、圆/圆弧</h3><ul>
<li>arcTo(x1, y1, x2, y2, radius)：不可靠不作介绍</li>
</ul>
<ul>
<li><p>arc(x, y, radius, 起始弧度, 结束弧度, 方向)：</p>
<ol>
<li>弧度的计算：180°为Π（Math.PI），公式：角度/180*Math.PI = 弧度。</li>
<li>弧度为零：圆心的水平向右方向。</li>
<li>方向：true逆时针，false/不写 顺时针</li>
</ol>
</li>
</ul>
<p>举例</p>
<pre><code>//画圆
ctx.arc(100,100,50,0,Math.PI*2)
//圆弧
ctx.arc(100,100,50,0.3,6,true)
//填充圆（弧）
ctx.fill()
//描边
ctx.stroke()
</code></pre><h3 id="3、二次-三次-贝塞尔曲线"><a href="#3、二次-三次-贝塞尔曲线" class="headerlink" title="3、二次/三次 贝塞尔曲线"></a>3、二次/三次 贝塞尔曲线</h3><ol>
<li>quadraticCurveTo(x0,y0,x1,y1): 二次，起点（控制点）（x0,y0），终点（x1,y1）</li>
<li>dezierCurveTo(x0,y0,x1,y1,x2,y2)：三次，控制点1/2：(x0,y0)/(x1,y1)，结束点：(x2,y2)</li>
</ol>
<p>虽然不熟悉贝塞尔曲线，但通过多次绘制它可以用来绘制有用的图形：</p>
<pre><code>//二次
 ctx.beginPath();
 ctx.moveTo(75,25);
 ctx.quadraticCurveTo(25,25,25,62.5);
 ctx.quadraticCurveTo(25,100,50,100);
 ctx.quadraticCurveTo(50,120,30,125);
 ctx.quadraticCurveTo(60,120,65,100);
 ctx.quadraticCurveTo(125,100,125,62.5);
 ctx.quadraticCurveTo(125,25,75,25);
 ctx.stroke();
</code></pre><p>结果图：</p>
<p><img src="https://i.loli.net/2018/11/16/5bee35a1dd3e6.jpg" alt="对话框"></p>
<p>还可以用三次贝塞尔曲线画心型等等。</p>
<h3 id="4、Path2D"><a href="#4、Path2D" class="headerlink" title="4、Path2D"></a>4、Path2D</h3><p>可以把创建的图形存为path2D对象，再引用它们。</p>
<p>code:</p>
<pre><code>ctx.strokeStyle = &quot;red&quot;
ctx.fillStyle = &quot;#00eeee&quot;
//存对象
var rectangle = new Path2D()
rectangle.rect(10, 10, 50, 50)

var circle = new Path2D();
circle.arc(100, 35, 25, 0, 2 * Math.PI)
//用对象
ctx.stroke(rectangle);
ctx.fill(circle);    
</code></pre><p>结果：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9qj7e0ypj2066034we9.jpg" alt="path2d"></p>
<h3 id="5、使用SVG-paths"><a href="#5、使用SVG-paths" class="headerlink" title="5、使用SVG paths"></a>5、使用SVG paths</h3><p>获取路径时以svg或canvavs方式重用：</p>
<pre><code>var p = new Path2D(&quot;M 80 20 h 20 v 80 h -80 Z&quot;);
ctx.fill(p)
//M 80 20 这条路径先移动到点（80，20），
//h 20 向右移20
//v 80 向下移80
//h -80 向左移80
//z  回到起点
</code></pre><p>结果图：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9qjgm0flj204203o741.jpg" alt="svg"></p>
<h2 id="七、指定颜色"><a href="#七、指定颜色" class="headerlink" title="七、指定颜色"></a>七、指定颜色</h2><p>如：</p>
<pre><code>ctx.fillStyle = &quot;red&quot;    //指定填充颜色为红色
ctx.strokeStyle = &quot;green&quot;   //指定描边为绿色
</code></pre><h2 id="八、指定透明度"><a href="#八、指定透明度" class="headerlink" title="八、指定透明度"></a>八、指定透明度</h2><p>如：</p>
<pre><code>ctx.fillStyle = &quot;rgba(0,0,0,0.5)&quot;
</code></pre><h3 id="所有图形的透明度"><a href="#所有图形的透明度" class="headerlink" title="所有图形的透明度"></a>所有图形的透明度</h3><pre><code>ctx.globalAlpha =  0.2
//透明度取值为0.0(完全透明)-1.0(完全不透明)
</code></pre><h2 id="九、线条样式"><a href="#九、线条样式" class="headerlink" title="九、线条样式"></a>九、线条样式</h2><ol>
<li>lineWidth=：线条宽度</li>
<li>lineCap=：线条末端<ul>
<li>（butt 默认，不加）</li>
<li>（round 加半圆半径为线条宽度一半）</li>
<li>（square 加方形）</li>
</ul>
</li>
<li>lineJoin=：线条连接处<ul>
<li>（miter 默认，尖角）</li>
<li>（bevel 平）</li>
<li>（round 圆弧）</li>
</ul>
</li>
<li>miterLimit=：连接处最大长度（内角顶点~外角顶点）</li>
<li>setLineDash()：虚线样式，接受一个数组，指定线段与间隙交替</li>
<li>getLineDash()：返回含虚线样式的数组</li>
<li>lineDashOffsest=：设置虚线偏移量。通过循环改变偏移量，有虚线在动的效果，通过延时函数控制速度。</li>
</ol>
<p>虚线例子：</p>
<pre><code>ctx.setLineDash([4, 2])
ctx.lineDashOffset = 10
ctx.strokeRect(100,20, 100, 100)
</code></pre><p>结果：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31gy1fx9qk9q99qj206904edfl.jpg" alt="虚线"></p>
<h2 id="九、渐变Gradient"><a href="#九、渐变Gradient" class="headerlink" title="九、渐变Gradient"></a>九、渐变Gradient</h2><ol>
<li><p>创建Gradient对象（并定义渐变位置）</p>
<ul>
<li>createLInearGradient(x1,y1,x2,y2)：线性的渐变，参数为起点和终点。</li>
<li>createRadiusGradient(x1,y1,r1,x2,y2,r2)：圆形，参数为两个圆圆心和半径。</li>
</ul>
</li>
<li><p>渐变颜色</p>
<ul>
<li>gradient.addColorStop(position,color)：参数为欸位置（0.0~1.0）和颜色。</li>
</ul>
</li>
<li><p>把gradient对象赋给fillStyle/strokeStyle</p>
</li>
</ol>
<p>举例：</p>
<pre><code>//1.创建对象，定义位置
var gradient = ctx.createLinearGradient(0,0,0,150)
//2、定义颜色
//0-0.5：蓝-绿
//0.5-1：红-白-黑
gradient.addColorStop(0, &apos;#0000ff&apos;)
gradient.addColorStop(0.5, &apos;#00ff00&apos;)
  gradient.addColorStop(0.5, &apos;#ff0000&apos;)
gradient.addColorStop(0.75, &apos;#fff&apos;)
  gradient.addColorStop(1, &apos;#000&apos;)

  // 3、将 渐变对象 赋给fillStyle
  ctx.fillStyle = gradient
ctx.strokeStyle = gradient

  // 4、画图
  ctx.fillRect(10,10,100,130)
ctx.strokeRect(130,10,100,130);
</code></pre><p>结果图：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31gy1fx9qknvff6j208u054t8j.jpg" alt="渐变"></p>
<h2 id="十、添加图案-Pattern"><a href="#十、添加图案-Pattern" class="headerlink" title="十、添加图案 Pattern"></a>十、添加图案 Pattern</h2><p>将image对象赋给图案，将图案作为填充样式：代码</p>
<pre><code>//1、创建image对象
var img = new Image();
  img.src = &apos;图片路径&apos;;
  img.onload = function(){
    // 2、用image，创建图案
    var ptrn = ctx.createPattern(img,&apos;repeat&apos;);
    // 3、用图案作填充样式
    ctx.fillStyle = ptrn;
    ctx.fillRect(0,0,350,350);
  }
</code></pre><p>结果：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9qjh5fiqj20a40a7whm.jpg" alt="图案"></p>
<h2 id="十一、阴影shadows"><a href="#十一、阴影shadows" class="headerlink" title="十一、阴影shadows"></a>十一、阴影shadows</h2><ol>
<li>shadowOffsetX = float<br>shadowOffsetX 和 shadowOffsetY ：向右延申距离</li>
<li>shadowOffsetY = float：向下延申距离<br>3、shadowBlur = float：阴影模糊程度<br>4、shadowColor = color：阴影颜色</li>
</ol>
<h2 id="十二、绘制文本"><a href="#十二、绘制文本" class="headerlink" title="十二、绘制文本"></a>十二、绘制文本</h2><ol>
<li>ctx.fillText(‘kakami’,10,10)：填充文字和位置</li>
<li>ctx.strkeText(‘kakami’,10,10)：只描边的文字</li>
<li>ctx.font = “48px serif”：设置font</li>
<li>ctx.textAlign=start(默认)/end/left/right/center：文字对齐方式</li>
<li>textBaseline = top/hanging/middle/bottom/alphabetic(默认)/ideographic：基线对齐方式</li>
<li>direction = ltr/rtl/inherit(默认)</li>
</ol>
<h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><ol>
<li>画完一个（描边）图形之后，没有再次写ctx.beginPath()就画一个填充图形，那第一个图形也会被填充。</li>
<li>一定要写fill/stroke()</li>
<li>使用封装函数对于减少代码量以及复杂度十分有用，如roundedRect()</li>
<li>roundedRect(ctx,10,10,5,5,3)能画圆角矩形。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Drawing_text" target="_blank" rel="noopener">MDN有关canvas</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/01/canvas的使用/" data-id="cju6g672z000s1o7laz643tqz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（H）canvas的使用/">（H）canvas的使用</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LocalStorage与SessionStorage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/30/LocalStorage与SessionStorage/" class="article-date">
  <time datetime="2018-08-30T03:18:00.000Z" itemprop="datePublished">2018-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/30/LocalStorage与SessionStorage/">LocalStorage与SessionStorage</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="在学习LocalStorage前先来看一下，JS中变量有什么问题："><a href="#在学习LocalStorage前先来看一下，JS中变量有什么问题：" class="headerlink" title="在学习LocalStorage前先来看一下，JS中变量有什么问题："></a>在学习LocalStorage前先来看一下，JS中变量有什么问题：</h3><pre><code>&lt;script&gt;
    var age = 18
    console.log(&apos;age = &apos; + age)
    //结果输出 age = 18
&lt;/script&gt;
</code></pre><p>在页面中改变变量 age 的值：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-11/55819352.jpg" alt="age"></p>
<p>现在的 age = 19</p>
<p>但是，刷新页面之后呢？</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-11/16450453.jpg" alt="age"></p>
<p>可以看到刷新之后页面中的age值已经又变回了 18，这就是问题所在。</p>
<h3 id="有什么办法可以使一个变量一直存在页面中或者从一个页面跳到另一个页面时值不变呢？答案就是-将变量保存在-LocalStorage里。"><a href="#有什么办法可以使一个变量一直存在页面中或者从一个页面跳到另一个页面时值不变呢？答案就是-将变量保存在-LocalStorage里。" class="headerlink" title="有什么办法可以使一个变量一直存在页面中或者从一个页面跳到另一个页面时值不变呢？答案就是 将变量保存在 LocalStorage里。"></a>有什么办法可以使一个变量一直存在页面中或者从一个页面跳到另一个页面时值不变呢？答案就是 将变量保存在 LocalStorage里。</h3><p>LocalStorage是不存储在页面中的，它存储在C盘（windows）的一个文件中。 </p>
<p>使用localStorage存变量：</p>
<pre><code>&lt;script&gt;
    let age = localStorage.getItem(&apos;age&apos;) //读取名为age的变量值
    if(! age) {
        age = 18
    }else {
        age = (+age) + 1 //（+age）将age变成数字，同 parseInt(age, 10)
    }
    console.log(&apos;age = &apos; + age)
    localStorage.setItem(&apos;age&apos;, age) //将age存进localStorage
&lt;/script&gt;
</code></pre><p>这样每次刷新都会将age加1，不会覆盖之前作的改变。</p>
<p>打开控制台-&gt;Application-&gt;Local Storage，可以看到：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9r4zw6osj20ki06xt8x.jpg" alt="图0"></p>
<p>可以看到当前的age值为 27，可以拉动下面的框，出现 key-value</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-11/13943624.jpg" alt="图1"></p>
<p>控制台打印：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9r2960l0j208y0490sl.jpg" alt="图2"></p>
<h3 id="localStorage典型应用：记录是否提示过用户"><a href="#localStorage典型应用：记录是否提示过用户" class="headerlink" title="localStorage典型应用：记录是否提示过用户"></a>localStorage典型应用：记录是否提示过用户</h3><p>代码如下：</p>
<pre><code>let prompted = localStorage.getItem(&apos;是否提示&apos;)
if(!prompted){
    alert(&apos;这里是提示内容...&apos;)
    localStorage.setItem(&apos;是否提示&apos;,true)
}
</code></pre><p>只有第一次进去页面会有此提示：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9r68yhbwj20cm03zt8l.jpg" alt="图5"></p>
<p>点击确定会看到localStorage增加了一项 <code>是否提示：true</code> ：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9r28qtbjj20kc04waa4.jpg" alt="图6"></p>
<h3 id="localStorage接口"><a href="#localStorage接口" class="headerlink" title="localStorage接口"></a>localStorage接口</h3><p>1、增加一个数据项: </p>
<pre><code>localStorage.setItem(&apos;name&apos;, &apos;xiaoxiao&apos;)
</code></pre><p>2、读取一个localStorage项：</p>
<pre><code>localStorage.getItem(&apos;name&apos;)    //xiaoxiao
localStorage.name    //xiaoxiao
</code></pre><p>3、读取所有localStorage项：</p>
<pre><code>localStorage.valueOf()    //Storage {age: &quot;33&quot;, name: &quot;xiaoxiao&quot;, length: 2}
</code></pre><p>4、读取第i项变量名：</p>
<pre><code>localStorage.key(i)    //length不算在里面
</code></pre><p>5、读取localStorage项数：</p>
<pre><code>localStorage.length    //2，只有age和name
</code></pre><p>6、移除一个localStorage项：</p>
<pre><code>localStorage.remove(&apos;name&apos;)
</code></pre><p>7、移除所有localStorage项：</p>
<pre><code>localStorage.clear()
</code></pre><p>8、检查localStorage里是否保存某个变量：</p>
<pre><code>localStorage.hasOwnProperty(&apos;name&apos;) //true
</code></pre><p>9、将数组转为字符串：</p>
<pre><code>localStorage.array = [1,2,3,4]  //[]
localStorage.array.toLocaleString()   //&quot;1,2,3,4&quot;
</code></pre><p>10、存储JSON对象为字符串：</p>
<pre><code>let sisters = {
    xiaoxiao: {
        name: &quot;xiaoxiao&quot;,
        age: 10
    },
    xiaolu: {
        name: &quot;xiaolu&quot;,
        age: 8
    }
}
localStorage.sisters = window.JSON.stringify(sisters)
//    &quot;{&quot;xiaoxiao&quot;:{&quot;name&quot;:&quot;xiaoxiao&quot;,&quot;age&quot;:10},&quot;xiaolu&quot;:{&quot;name&quot;:&quot;xiaolu&quot;,&quot;age&quot;:8}}&quot;

window.JSON.parse(localStorage.sisters) //可将字符串还原为对象
</code></pre><h3 id="SessionStorage与localStorage比较"><a href="#SessionStorage与localStorage比较" class="headerlink" title="SessionStorage与localStorage比较"></a>SessionStorage与localStorage比较</h3><p>SessionStorage作用与用法LocalStorage基本相同，不同的是，localStorage是永久有效的，除非用户清理缓存，但是sessionStorage会在页面会话后就清除。</p>
<p><strong>页面会话</strong>：在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</p>
<p>要注意的是：localStorage和sessionStorage都是仅限于页面的协议，虽然没有同源策略那么严格，但也只有相同域名的页面才能互相读取。</p>
<h4 id="sessionStorage用法与localStorage差不多，简单介绍："><a href="#sessionStorage用法与localStorage差不多，简单介绍：" class="headerlink" title="sessionStorage用法与localStorage差不多，简单介绍："></a>sessionStorage用法与localStorage差不多，简单介绍：</h4><pre><code>// 保存数据到sessionStorage
sessionStorage.setItem(&apos;key&apos;, &apos;value&apos;);

// 从sessionStorage获取数据
var data = sessionStorage.getItem(&apos;key&apos;);

// 从sessionStorage删除保存的数据
sessionStorage.removeItem(&apos;key&apos;);

// 从sessionStorage删除所有保存的数据
sessionStorage.clear();
</code></pre><h3 id="localStorage与cookie比较"><a href="#localStorage与cookie比较" class="headerlink" title="localStorage与cookie比较"></a>localStorage与cookie比较</h3><p>事实上，localStorage是一个新的对象，为了使前端能够存储数据创建，以前都是由cookie完成，但是cookie要上传到服务器，使得页面加载非常地慢速，所以现在不推荐使用cookie，他们两者主要区别是：</p>
<ul>
<li>cookie需发送到服务器，localStorage与HTTP请求无关。</li>
<li>cookie最大存储量在4kb左右，localStorage在5Mb左右（不同的浏览器各不相同）。</li>
<li>cookie默认在页面关闭后清除（后端可以设置清除时间），LocalStorage理论上永久有效，除非用户清理缓存。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/30/LocalStorage与SessionStorage/" data-id="cju6g672m000l1o7lze8k1utv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（W）Web-Storage/">（W）Web Storage</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Session学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/28/Session学习/" class="article-date">
  <time datetime="2018-08-28T03:25:38.000Z" itemprop="datePublished">2018-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/28/Session学习/">Session学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上次学习了<a href="https://lxiaox.github.io/2018/08/26/%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E4%B8%8Ecookie/" target="_blank" rel="noopener">登录注册与Cookie</a>，Cookie用于保存用户登录信息。</p>
<p>Cookie过程如下：</p>
<ol>
<li>服务器服务器通过 Set-Cookie 头给客户端一串字符串</li>
<li>客户端每次访问相同域名的网页时都带上这段字符串，也就是Cookie</li>
<li>服务器通过Cookie读取用户id等，填充并返回相应页面</li>
<li>客户端在一段时间内保存Cookie，Cookie默认网页关闭后失效，但后台可以设置过期时间。</li>
</ol>
<p>但是Cookie存在一个问题，那就是用户是可以篡改Cookie信息的。<code>打开控制台-&gt;Application-&gt;Cookies</code>，我们就可以看到Cookie，改变它的值，如果我们把id改为别的id，那就可以直接登录别人的账户，这是非常不合理的。</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9rej3yfrj20qc07gjrr.jpg" alt="控制台Cookies"></p>
<p>所以我们用到另外一种技术：</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>如果把Cookie理解为公园的一张门票，上面记录了你的姓名，性别等信息，那么Session就像是一张保密的门票，它只记录你的‘入场号’，而你的信息则存在与公园内部的记录册中，所以当你把门票出示给工作人员时，他仍可以根据入场号搜索到你的姓名，并说欢迎您，xxx。</p>
<p>Session的工作原理正是如此：</p>
<ol>
<li>当用户登录后，服务器就会给用户生成相应的随机数，SessionID</li>
<li>将SessionID<strong>通过Cookie</strong>返回给客户端</li>
<li>客户端再次访问这个服务器的时候，带上这段Cookie</li>
<li>事实上服务器上有hash表存储了所有的Session，当服务器读取到了SesssionID，就可以找到对应的Session</li>
<li>最终得到用户的隐私信息，如id，邮箱。</li>
</ol>
<h4 id="Cookie、Session存储位置"><a href="#Cookie、Session存储位置" class="headerlink" title="Cookie、Session存储位置"></a>Cookie、Session存储位置</h4><p>Cookie是保存在客户端的，每次都随着请求发送给服务器。</p>
<p>而Session是存储在服务器端的，每次通过Cookie将SessionID发送到服务器。</p>
<p>Seesion缺点：所有用户的Sessioon都存储在服务器，这是很占内存的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/28/Session学习/" data-id="cju6g672v000p1o7lwbh3d2uo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（W）Session/">（W）Session</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-登录注册与cookie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/26/登录注册与cookie/" class="article-date">
  <time datetime="2018-08-26T07:33:42.000Z" itemprop="datePublished">2018-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/26/登录注册与cookie/">登录注册与Cookie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="注册与登录基本过程"><a href="#注册与登录基本过程" class="headerlink" title="注册与登录基本过程"></a>注册与登录基本过程</h2><p>登录与注册是我们日常浏览网页一个很普遍的行为，大部分网站都有用户登录机制。例如：当我们访问某一个网站时，如淘宝，不登录的时候也能看到淘宝的各种页面或者商品，但是收藏商品或将其添加至购物车时，就需要用户登录了，用户登录后就可以进行更多的操作。在用户眼中的登录注册就是用户名与密码输入正确，那么在程序中登录与注册过程中到底发生了什么？现在来总结一下：</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>首先，点击到注册页面，最简单的注册页面就是输入id（用户名或邮箱等）、输入密码、确认密码和注册按钮，通常前端程序员会在点击注册时进行一些验证，如邮箱用户名是否符合规范，两次密码是否匹配等，并作出一些修改提示，然后正确之后将这些信息发送给后端，这时后端程序员需要再进行验证，因为发送请求完全可以绕过页面的JS，比如使用curl发送请求，所以前端的验证是可有可无的，但后端的验证是必须的。当后端验证成功之后，就会将信息存入数据库。这时用户就可以进入登录页面进行验证。</p>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>登录页面与注册页面代码大同小异，当用户点击登录按钮时，浏览器就会将登录信息发送给服务器，也就是后端，后端服务器再将id与数据库中的数据进行比较，当找到匹配的id再进行密码验证，当这些都正确时，浏览器就会根据用户id获取到存储的用户信息，将相应信息填到页面中，然后将新的登录后的页面返回给客户端，也就是浏览器，展示出来。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>上面说到了服务器对用户登录的处理，事实上，在登录成功之后服务器还会做一件事情，那就是向浏览器发送一段cookie 信息，并保存在浏览器的response Header中，并且下次用户使用同一个浏览器访问这个页面时，浏览器向服务器发送请求时也会带上这段cookie数据。那么，cookie 到底是什么呢？</p>
<p>Cookie 就是一个小型的文本文件，它存储了用户的身份信息。</p>
<h4 id="cookie分类"><a href="#cookie分类" class="headerlink" title="cookie分类"></a>cookie分类</h4><p>cookie也是有时间限制的，一般默认20分钟左右，不同的浏览器不尽相同，当然也可以强制设置cookie的保存时间，没有设置期限的Cookie保存于浏览器<strong>内存</strong>，设置了过期时间就保存在<strong>硬盘</strong>中，所以按存储位置可分为<strong>内存Cookie</strong> 和 <strong>硬盘Cookie</strong>。内存cookie在浏览器关闭之后就会消失，硬盘cookie 则不会，除非用户手动删除，或到了过期时间，因此按保存时间又可以分为<strong>非持久Cookie</strong> 和 <strong>持久Cookie</strong>。</p>
<h3 id="为什么需要cookie"><a href="#为什么需要cookie" class="headerlink" title="为什么需要cookie"></a>为什么需要cookie</h3><ul>
<li>cookie的第一个作用就是<strong>记录历史</strong>。因为HTTP的无状态性，服务器不知道用户上一次作了什么，比如用户浏览器几个页面，买了几件物品，结账的时候却不知道买的物品是什么，cookie就可以记录商品信息。大致过程是：当用户选购了一样东西，服务器向用户发送页面的同时还会发送cookie记录着商品信息，当用户浏览新的页面时，又向服务器发送cookie，这样服务器就知道了购物信息，当用户想再添加商品时，只需追加cookie信息，最后结账时，服务器只需读取发来的cookie信息。</li>
<li>cookie第二个作用就是<strong>识别用户身份</strong>。当用户登录页面时，服务器会给每个用户分配id，并向页面发送送包含id的cookie，不同的用户登录时会带着不同的cookie，这样服务器就可以区分不同的用户了。</li>
<li>cookie还有一个典型应用就是自动登录，当用户登录时选中自动登录，那么下一次登录时就不需要再次输入用户名密码，这是因为服务器在用户登录之后会向用户发送cookie，cookie包含了登录凭证(用户名密码的加密形式)。只要cookie没到过期时间，下次登录浏览器就会向服务器发送cookie，cookie相当于一张门票，让用户不需再次输入用户名密码而 自动登录。</li>
</ul>
<h3 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h3><p>服务器端通过下列代码可以设置cookie：</p>
<pre><code>setcookie($name, $value, $expire, $path, $domain, $secure)
//eg：response.setHeader(&apos;Set-Cookie&apos;, `sign_in_email=${email}`) 
</code></pre><p>这里要注意 <code>$domain</code> 指定了域名，cookie是不能跨域访问的。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener">更多设置cookie的语法</a></p>
<h3 id="cookie的缺陷"><a href="#cookie的缺陷" class="headerlink" title="cookie的缺陷"></a>cookie的缺陷</h3><ol>
<li>Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。</li>
<li>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。</li>
<li>Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/26/登录注册与cookie/" data-id="cju6g673n001f1o7l4m3e26i2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（W）登录注册、cookie/">（W）登录注册、cookie</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/25/JS数据结构/" class="article-date">
  <time datetime="2018-08-25T03:11:17.000Z" itemprop="datePublished">2018-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/25/JS数据结构/">JS中的数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天简要总结一下 JS 中的几种数据结构。</p>
<h2 id="1、哈希"><a href="#1、哈希" class="headerlink" title="1、哈希"></a>1、哈希</h2><blockquote>
<p>哈希表(Hash table，也叫散列表)，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
</blockquote>
<p>简单地说，形如键值一一对应的数据结构就是哈希。用哈希可以表示JS中的对象，根据是key-value对应，key表示对象属性，value表示属性值。如：</p>
<pre><code>var student = {
    &apos;name&apos;: &apos;Mary&apos;,
    &apos;sex&apos;: &apos;female&apos;,
    &apos;age&apos;: &apos;18&apos;,
  //&apos;key&apos;: &apos;value&apos;
}
</code></pre><p>其实<strong>数组</strong>就是一个特殊的哈希，它的 key 为排列好的数字,并且有一个key 是 length，表示数组长度。</p>
<pre><code>var array = [0,1,2,3]
//可以看作
var array = {
    &apos;0&apos;: 0,
    &apos;1&apos;: 1,
    &apos;2&apos;: 2,
    &apos;3&apos;: 3,
    &apos;length&apos;: 4
}
</code></pre><p>数组的优点是容易查找修改，缺点是难以在元素中间增加删除，因为每在中间增加或删除几个元素都意味着它之后的所有元素就要进行大挪移，都前进或都后退几位。</p>
<h2 id="2、栈"><a href="#2、栈" class="headerlink" title="2、栈"></a>2、栈</h2><p>栈是一种遵从<strong>后进先出</strong>（Last In First Out）的有序列表。栈顶元素永远是最新元素，每次只能从栈顶开始取出。可以想象成放在一只小箱子里的书本，每次往里放都放在最上面，也只能从最上面开始拿。栈的特点就是 先进后出，后进先出。</p>
<p>栈需要有如下的方法:</p>
<ul>
<li>push(element(s)): 添加几个元素到栈顶</li>
<li>pop(): 移除并返回栈顶元素</li>
<li>peek(): 返回栈顶元素</li>
<li>isAmpty: 检查栈是否为空，为空则返回true</li>
<li>clear: 移除栈中所有元素</li>
<li>size: 返回栈中元素个数。</li>
<li>print: 以字符串显示栈中所有内容</li>
</ul>
<h2 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h2><p>对列与栈很像，不过特点是 <strong>先进先出</strong>，这就跟我们人的排队是一样的。每次添加只能加在最后面，移除只能移除最前面的数据。</p>
<p>队列需要的方法：</p>
<ul>
<li>enqueue(element(s)): 向队列尾部添加几个项</li>
<li>dequeue(): 移除队列的第一项</li>
<li>front(): 返回队列的第一个元素</li>
<li>其他方法同栈一样。</li>
</ul>
<h2 id="4、链表"><a href="#4、链表" class="headerlink" title="4、链表"></a>4、链表</h2><blockquote>
<p>链表是一组节点组成的集合，每个节点都使用一个对象的引用来指向它的后一个节点。指向另一节点的引用讲做链。</p>
</blockquote>
<ol>
<li>单向链表中每个节点都具有两个部分，一个储存自身信息，一个指向下一个节点。</li>
<li>双向链表中每个节点则具有三个部分，一个储存自身信息，一个指向上一个节点，一个指向下一个节点。</li>
</ol>
<p>因此链表区别于数组的是容易增加删除，只需要改变指针指向即可，但是它想要找到一个节点却很困难，只能从第一个节点开始不停地找下一个节点直到找到。</p>
<p><em>队列、栈可以用数组实现，而链表可以用哈希（即JS 对象）实现。</em></p>
<p>这里说一下，哈希正是一种结合了数组和链表的优点的数据结构，既容易寻址查找，又容易插入删除。</p>
<h2 id="5、树"><a href="#5、树" class="headerlink" title="5、树"></a>5、树</h2><p>之前的栈、队列、链表等都是顺序数据结构，而树就是一种<strong>非顺序结构</strong>。树形状像一颗根在上的倒挂的树，以此命名，如下图：</p>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9qzkcoshj207c05b745.jpg" alt="树"></p>
<h4 id="树的基本概念："><a href="#树的基本概念：" class="headerlink" title="树的基本概念："></a>树的基本概念：</h4><ul>
<li>节点：树中的每个元素都叫节点；</li>
<li>根节点：没有父节点的节点，树只有唯一的根节点，图中为 A；</li>
<li>子节点：从节点延申而下的都叫子节点；</li>
<li>内部节点：有子节点的节点（B C D）或称中间节点；</li>
<li>叶子节点：没有子节点的节点(E F G H I J)，又称终端节点；</li>
<li>节点层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>节点深度：从根 到 该节点的路径长，根的深度为0；</li>
<li>节点高度：从该节点 到 一个叶子节点的最长路径长，叶子节点的高度为0；</li>
<li>树的深度：所有节点深度的最大值；</li>
<li>树的高度：所有节点高度的最大值；</li>
<li>节点的度：一个节点含有的子树的个数称为该节点的度；</li>
<li>树 的 度：一棵树中，最大的节点的度称为树的度；</li>
<li>注：关于根节点的深度高度的基数为0 或1 说法不一。</li>
</ul>
<h4 id="树的种类："><a href="#树的种类：" class="headerlink" title="树的种类："></a>树的种类：</h4><ol>
<li>无序树：树中任意节点的子节点之间没有顺序关系，也称为自由树；</li>
<li>有序树：树中任意节点的子节点之间有顺序关系；<ul>
<li>二叉树：每个节点最多含有两个子树的树称为二叉树；</li>
<li>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。</li>
</ul>
</li>
</ol>
<p>其中二叉树又分为：</p>
<ul>
<li>完全二叉树：除了最底层，所有层的节点数均达到最大值，最底层的左右节点连续紧密地排列，这样的二叉树叫做完全二叉树。</li>
<li>满二叉树：所有叶子节点均在最底层的二叉树。<em>满二叉树和完全二叉树用数组就可以表示</em>。</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9qzkn7vqj209g044wed.jpg" alt="满/完全二叉树"></p>
<ul>
<li>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li>
<li>排序二叉树(二叉查找树)：只允许你在左侧节点储存比父节点小的值，右侧只允许储存比父节点大的值。也称二叉搜索树、有序二叉树；</li>
</ul>
<p><img src="https://ws1.sinaimg.cn/large/d826ea31ly1fx9qzkicxoj20al06v0t0.jpg" alt="二叉查找树"></p>
<h5 id="还有一种特殊的数据结构—-堆"><a href="#还有一种特殊的数据结构—-堆" class="headerlink" title="还有一种特殊的数据结构—-堆"></a>还有一种特殊的数据结构—-堆</h5><p><strong>堆(heap)</strong>，形状上像完全二叉树，堆的特点是所有父节点都比它的子节点要大（最大堆） 或者要小（最小堆）。正如我们堆东西将大的放下面，小的放上面，树不能表现出这种特性，所以叫做堆。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/25/JS数据结构/" data-id="cju6g672a000f1o7l6vsplmmh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（J）JS-数据结构/">（J）JS-数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/23/JS排序算法/" class="article-date">
  <time datetime="2018-08-23T03:54:32.000Z" itemprop="datePublished">2018-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/23/JS排序算法/">JS排序算法（学习ing）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不断更新中……</p>
<p>冒泡O(n^2)，选择O(n^2)，插入O(n^2)，快速，计数o(n)，归并，桶排序，基数排序……</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>基本思想：重复走访要排序的数列，一次比较两个元素，如果这两个数顺序错误就将其交换，每次走访都能找到一个最值，重复走访直到没有要进行交换的元素，那么排序就完成了。</li>
<li>时间复杂度：O(n^2)</li>
<li>冒泡排序过程（升序）：<ol>
<li>比较第一对相邻的元素，如果第一个比第二个大，就交换他们两个。</li>
<li>按1的方法比较第二对相邻元素，即第二个与第三个，以此类推直到最后一对元素，这时，最后的元素就是最大的数。</li>
<li>再次重复步骤1、2比较除最后一个数的所有元素。</li>
<li>如此每次都找到一个当前最大值下次不需在参与比较，直到没有任何一对数字需要比较。</li>
</ol>
</li>
<li><p>JS 代码：</p>
<pre><code>Array.prototype.bubbleSort = function() {
    var i, j, temp;
        //每轮比较让最大的冒到最上面，i：轮数=元素个数-1，因为this[0]不需要再比较。
    for (i = 0; i &lt; this.length - 1; i++)
            //每次选定this[j+1],所以j&lt;this.length-1; 第一轮j+1=this.length-1,第二轮j+1=this.length-2,...所以是要-i
        for (j = 0; j &lt; this.length - 1 - i; j++)
            if (this[j] &gt; this[j + 1]) {
                temp = this[j];
                this[j] = this[j + 1];
                this[j + 1] = temp;
            }
    return this;
};
var num = [2,9,5,8,10,1,32]
num.bubbleSort()
console.log(num)    // [1, 2, 5, 8, 9, 10, 32]
</code></pre></li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li>基本思想：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>
<li>时间复杂度：O(n^2)</li>
<li><p>JS 代码：</p>
<pre><code>Array.prototype.selectionSort = function() {
    var i, j, temp, min
        //每次选出最小的作为this[i]，i：选择的轮数=元素个数-1
    for (i = 0; i &lt; this.length - 1; i++) {
          min = i
            //每次从this[i]比较到最后一个：this.length-1；
        for (j = i + 1; j &lt; this.length; j++) {
            if (this[j] &lt; this[min]) {
              min = j
            }
        }
      temp = this[i]
      this[i] = this[min]
      this[min] = temp
    }            
    return this
}
var num = [2,9,5,8,10,1,32]
num.selectionSort()
console.log(num)    // [1, 2, 5, 8, 9, 10, 32]
</code></pre></li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>基本思想：将第一个元素视为已排列元素，取出下一个元素从后向前地与已排列元素进行对比，如果下一个元素（即新元素）比某个元素小，就将这个元素往后移一位，一直比较直到找到小于或等于新元素的，将新元素插到这个元素之后，再重复将多有元素排完。</li>
<li>时间复杂度：O(n^2)</li>
<li><p>JS 代码：</p>
<pre><code>Array.prototype.insertionSort = function() {
  var i, j
    //i表示待插入元素，从1开始，因为第一个已插到this[0]
  for(i = 1; i &lt; this.length; i++) {
    for(j = 0; j &lt; i; j++){
      if(this[i] &lt; this[j]){
            //默认j(0~i-1)是已经排好的，this[i]是待插的
            //this[i]&lt;this[j],则把它插入到this[j]的位置
        this.splice(j,0,this[i])
            //把this[i]插到this[j]之后，原来的this[i]变成了this[i+1]，把它删掉
        this.splice(i+1,1)
        break
      }
    }
  }
  return this
}
var num = [2,9,5,8,10,1,32]
num.insertionSort()
console.log(num)    // [1, 2, 5, 8, 9, 10, 32]
</code></pre></li>
</ul>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><ul>
<li>基本思想：利用一个新的数组，这个数组的第i项的值就是原数组值为i的个数，然后根据新数组排序。</li>
<li>时间复杂度：O(n+k)；空间:O(n+k)</li>
<li><p>JS 代码：</p>
<pre><code>Array.prototype.countSort = function() {
  let C = []
  for(let i = 0; i &lt; this.length; i++) {
    C[this[i]] &gt;0 ? C[this[i]] ++ : C[this[i]] = 1
  }
  this.splice(0)
  for(let i = 0; i &lt; C.length; i++) {
    while(C[i]-- &gt; 0)  this.push(i)

  }
  return this
}
const arr = [2,9,5,2,4,5,0,8,9,1,3]
console.log(arr.countSort())
</code></pre></li>
</ul>
<p>点击<a href="https://visualgo.net/en" target="_blank" rel="noopener">查看排序动画的网站</a>，可以更直观地了解排序的具体过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/23/JS排序算法/" data-id="cju6g6726000d1o7l8rhjyvl0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（S）排序算法-js/">（S）排序算法-js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AJAX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/23/AJAX/" class="article-date">
  <time datetime="2018-08-23T01:59:51.000Z" itemprop="datePublished">2018-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/23/AJAX/">AJAX</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前我们介绍了JSONP与跨域，JSONP是一种通过 script 发送请求的跨域技术，但是我们也提到了 jsonp 的缺点：</p>
<p>那就是 jsonp 是通过 script 只能发送 GET 请求，并只能以脚本运行。</p>
<p>那么有没有方式能实现各种请求方式<code>（get、post、put、delete...）</code>，并且我们想以什么方式展示都可以呢？</p>
<p>针对这个需求，微软率先做出了突破：</p>
<p>IE 5 在JS中引入了一个 ActiveX 对象，使得 JS 可以直接发起 HTTP 请求，随后 Mozilla、Safari、Opera 等浏览器也引进该对象。</p>
<p>该对象被纳入 <a href="https://www.w3.org/Consortium/" target="_blank" rel="noopener">W3C</a> 规范，取名为 <code>XMLHttpRequest</code> 。</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>使用上述对象  XMLHttpRequest 发送请求的步骤：</p>
<ol>
<li>使用 XMLHttpRequest 发请求，</li>
<li>服务器返回XML格式的字符串（现在大多使用<a href="https://www.json.org/" target="_blank" rel="noopener">JSON</a>格式），</li>
<li>JS 解析 XML ，并更新局部页面。</li>
</ol>
<p><a href="https://zh.wikipedia.org/wiki/%E5%82%91%E8%A5%BF%C2%B7%E8%A9%B9%E5%A7%86%E5%A3%AB%C2%B7%E8%B3%88%E7%91%9E%E7%89%B9" target="_blank" rel="noopener">Jesse James Garrett</a> 将以上技术取名为 <code>AJAX</code> ，全称是 <code>Asynchronous JavaScript And XML</code>，意为异步的 JavaScript 和 <a href="https://zh.wikipedia.org/zh-hans/XML" target="_blank" rel="noopener">XML</a>。</p>
<h2 id="用原生JS发-AJAX-请求实例"><a href="#用原生JS发-AJAX-请求实例" class="headerlink" title="用原生JS发 AJAX 请求实例"></a>用原生JS发 AJAX 请求实例</h2><p>上文提到使用 AJAX 的基本步骤，现在写一个请求实例。<br>客户端JS代码：</p>
<pre><code>//页面中有一个 myButton 按钮，点击它发送请求。
myButton.addEventListener(&apos;click&apos;,(e)=&gt;{
    //创建XMLHttpRequest对象
    let request = new XMLHttpRequest()
    //配置请求：动作，协议，域名，路径...
    request.open(&apos;get&apos;,&apos;http://baidu.com/xyz&apos;)
    //1、发送XML请求
    request.send()
    //2、服务器发送XML(JSON)字符串
    //3、JS解析XML
    request.onreadystatechange = ()=&gt;{
        if(request.readyState === 4){
            if(request.status &gt;= 200 &amp;&amp; request.status &lt;300){
                let string = request.responseText
                //把JSON格式的字符串转换为JS对应值
                let object = wndow.JSON.parse(string)
            }else if(request.status &gt;= 400){
                console.log(&apos;说明请求失败&apos;) 
             }
        }
    }
})
</code></pre><p>服务端部分代码：</p>
<pre><code>if(path===&apos;/xxx&apos;){
    response.statusCode = 200
    //设置响应第四部分数据格式为json格式
    response.setHeader(&apos;Content-Type&apos;, &apos;text/json;charset=utf-8&apos;)
    //跨域
    response.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://abcdef.com:8001&apos;)
    response.write(`
    {
      &quot;note&quot;:{
        &quot;to&quot;: &quot;B同学&quot;,
        &quot;from&quot;: &quot;A同学&quot;,
        &quot;heading&quot;: &quot;打招呼&quot;,
        &quot;content&quot;: &quot;hi&quot;
      }
    }
    `)
    response.end()
</code></pre><p>上述代码即使用AJAX发送请求，及服务器返回数据的过程。</p>
<p>其中值得注意的是：<br> <code>response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;http://abcdef.com:8001&#39;)</code><br>这一行代码就是为了应对浏览器的同源策略（只有协议+域名+端口完全一致才能获取到请求的数据）的机制，</p>
<p>叫做 <code>CORS ( Cross-Origin Resource Sharing)</code>，即跨站资源共享。</p>
<p>代码中 <code>Access-Control-Allow-Origin</code> 告诉浏览器，允许后面的网页跨域访问。</p>
<h2 id="封装一个-ajax"><a href="#封装一个-ajax" class="headerlink" title="封装一个 ajax()"></a>封装一个 ajax()</h2><p>为了方便使用AJAX发送请求，我们可以将上面的客户端代码封装成一个函数 ajax()：</p>
<pre><code>window.jQuery.ajax = function(url,method,body,headers,success, fail){
    let request = new XMLHttpRequest()
    request.open(method,url)
    for(let key in headers) {
         let value = headers[key]
          request.setRequestHeader(key, value)
    }
    request.onreadystatechange = ()=&gt;{
        if(request.readyState === 4){
            if(request.status &gt;= 200 &amp;&amp; request.status &lt;300){
                success.call(&apos;undefined&apos;,request.responseText)
            }else if(request.status &gt;= 400){
                fail.call(&apos;undefined&apos;,request)
            }
        }
    }
    request.send(body)
}
</code></pre><p>这样我们使用的时候只需将： 请求方式，路径，请求体（请求第四部分），成功函数，失败函数 传 给 ajax() 即可。</p>
<p>事实上使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">promise</a> 升级这个 ajax() 使其更加方便使用。</p>
<pre><code>//这里我们可以将参数封装成一个对象（ES6语法,解构赋值）
window.jQuery.ajax = function({url,method,body,headers}){
    return new Promise(function(resolve, reject) {
        let request = new XMLHttpRequest()
        request.open(method, url)
        for(let key in headers) {
             let value = headers[key]
              request.setRequestHeader(key, value)
        }
        request.onreadystatechange = () =&gt; {
            if (request.readyState === 4) {
                if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) {
                    resolve.call(&apos;undefined&apos;, request.responseText)
                } else if (request.status &gt;= 400) {
                    reject.call(&apos;undefined&apos;, request)
                }
            }
        }
        request.send(body)
    })
}

//按以下方式调用
jQuery.ajax({
    url: &apos;/xxx&apos;,
    method: &apos;get&apos;
}).then(success, fail)
</code></pre><h2 id="AJAX-的功能"><a href="#AJAX-的功能" class="headerlink" title="AJAX 的功能"></a>AJAX 的功能</h2><ul>
<li>客户端的 JS 发送请求</li>
<li>服务端的 JS 发送响应</li>
</ul>
<p>一、客户端 JS 设置请求各部分：</p>
<ol>
<li>第一部分 <code>request.open(&#39;get&#39;, &#39;/xxx&#39;)</code></li>
<li>第二部分 <code>request.setHeader(&#39;content-type&#39;,&#39;x-www-form-urlencoded&#39;)</code></li>
<li>第四部分 <code>request.send(&#39;a=1&amp;b=2&#39;)</code></li>
</ol>
<p>二、客户端 JS 获取响应各部分</p>
<ol>
<li>第一部分 <code>request.status（响应码） / request.statusText（响应码解释）</code></li>
<li>第二部分 <code>request.getResponseHeader() / request.getAllResponseHeaders()（一个或所有响应头）</code></li>
<li>第四部分 <code>request.responseText</code></li>
</ol>
<p>三、服务端 JS 获取请求各部分</p>
<ol>
<li>第一部分 <code>request.method，request.url</code></li>
<li>第二部分 <code>request.header</code></li>
<li>第四部分 <code>request.body</code></li>
</ol>
<p>四、服务端 JS 设置响应各部分：</p>
<ol>
<li>第一部分 <code>response.statusCode = 200</code></li>
<li>第二部分 <code>response.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf-8&#39;)</code></li>
<li>第四部分 <code>response.write(&#39;hi...&#39;)</code></li>
<li>响应结束 <code>response.end()</code></li>
</ol>
<h3 id="AJAX优缺点"><a href="#AJAX优缺点" class="headerlink" title="AJAX优缺点"></a>AJAX优缺点</h3><p>1.优点：</p>
<ul>
<li>无刷新更新数据：以前是响应传回一个新的html文件，而Ajax无需传输不需要的未改变的数据，减少响应时间，提高用户体验</li>
<li>异步执行：允许用户继续其他操作</li>
<li>降低服务器负担：一些简单的判断操作可在客户端执行</li>
<li>基于标准被广泛支持</li>
<li>数据与页面分离</li>
</ul>
<p>2.缺点：</p>
<ul>
<li>增加客户端负担</li>
<li>不支持浏览器back按钮和history事件，即破坏浏览器机制</li>
<li>破环了程序出错处理机制</li>
<li>带来了安全漏洞</li>
<li>其他：对搜索哦引擎支持弱，移动设备支持弱等</li>
</ul>
<p>另：本文中使用了</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">promise语法</a></li>
<li><a href="https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html" target="_blank" rel="noopener">回调函数</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/23/AJAX/" data-id="cju6g671c00001o7lbqx5kl6x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（W）ajax/">（W）ajax</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JSONP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/17/JSONP/" class="article-date">
  <time datetime="2018-08-17T02:22:50.000Z" itemprop="datePublished">2018-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/17/JSONP/">JSONP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JSONP（全称是 JSON with Padding）是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。JSONP通过GET请求向服务器请求数据。</p>
<h2 id="浏览器发送请求的历史"><a href="#浏览器发送请求的历史" class="headerlink" title="浏览器发送请求的历史"></a>浏览器发送请求的历史</h2><p>在了解JSONP之前，先来看看在JSONP之前浏览器是怎么向服务器发送请求的，前端程序员经过长时间的探索，曾先后使用过form、img等标签发请求，然而</p>
<ul>
<li>form（可以发送post、get等请求）表单会刷新页面，在新的页面中显示成功或失败，这个时候可以将新页面展示在iframe中，但这专门用来防止刷新的iframe无疑是碍眼的；</li>
<li>img标签（发送get请求）只知道成功、失败，无法获取更多的数据；</li>
<li>a标签（发送get请求）同样会刷新页面；</li>
<li>link（发送get请求）只能以css、favcon的形式展示；</li>
</ul>
<h2 id="SRC"><a href="#SRC" class="headerlink" title="SRC"></a>SRC</h2><p>那有什么办法能够更好的发送请求并得到数据呢？程序员发现script标签很好地实现了这种需求，并将这种解决策略称为<strong>SRC</strong>（Server Rendered JavaScript）即服务器返回JS。顾名思义，在这种方法中，浏览器向服务器请求script，服务器则进行相关操作，并返回一段JS数据告诉客户端也就是浏览器页面进行局部刷新。</p>
<p>接下来看客户端的代码：</p>
<pre><code>&lt;body&gt;
    &lt;p style=&quot;color:red;&quot;&gt;您的余额是&lt;span id=amount&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;&lt;/p&gt;
    &lt;button id=button&gt;付款&lt;/button&gt;
    &lt;script&gt;
        $(&apos;#button&apos;).on(&apos;click&apos;,function(){
           //首先新建一个scrippt标签，路径为/pay
           let script=document.createElement(&apos;script&apos;) 
           script.src=&apos;pay&apos; 
           document.body.appendChild(script)
           //加载成功后删除这个script，节省内存
           script.onload=function(e){
                e.currentTarget.remove()
            }
           //script加载失败通知用户
           script.onerror=function(e){
                alert(&apos;fail&apos;); 
                e.currentTarget.remove()
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre><p>服务端代码：</p>
<pre><code>if(path === &apos;/&apos;){
    let string=fs.readFileSync(&apos;./index.html&apos;,&apos;utf8&apos;)
    let amount=fs.readFileSync(&apos;./db&apos;,&apos;utf8&apos;)
    //这里的db为自建的文件充当数据库
    string=string.replace(&apos;&amp;&amp;&amp;amount&amp;&amp;&amp;&apos;,amount)
    response.statusCode = 200
    //写响应头
    response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;)
    //响应体，即返回给浏览器的内容
    response.write(string)
    response.end()
} else if (path === &apos;/pay&apos;){
    let amount=fs.readFileSync(&apos;./db&apos;,&apos;utf8&apos;)
    amount--    //付款1元，余额减1
    //新的余额写进数据库
    fs.writeFileSync(&apos;./db&apos;,amount)  
    response.statusCode = 200
    response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript;charset=utf-8&apos;)
    //这里是返回给客户端的JS代码
    response.write(`
      amount.innerText--
    `) 
    response.end()
}
</code></pre><p>这就是SRC的流程，然而这段代码中还存在着一个问题，不难看出，这里是由后端代码返回操作页面的JS代码，这就要求后端程序员掌握前端代码写法，并且必须对页面内容非常地熟悉，我们把这种代码杂糅称为代码的耦合，那么，为了解决这个问题，就说到了今天的重头戏–JSONP。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>上面说到了解决代码耦合，方法就是将上述后端写的前端代码，先封装为一个函数写在js中，发送script请求时，同时将这个函数作为请求参数传给服务器，这样后端就不需要写这些代码，只需要调用这个函数就行了。<br>代码修改如下：</p>
<pre><code>//1、客户端加上请求参数
//注意，为了统一，请求参数的名字规定叫做callback，以便所有人使用
script.src=&apos;/pay?callback=函数名&apos;
//2、封装函数，注意这里的函数名一般都加上随机以免造成变量名冲突。
//例如: let 函数名 = &apos;xxx&apos; + parseInt(Math.random()*10000,10)
window.函数名=function(result){
        amount.innerText = result.left
}

//3、服务器，修改原来的请求头数据格式javascript为json
response.setHeader(&apos;Content-Type&apos;, &apos;application/json;charset=utf-8&apos;)
//4、修改响应第四部分，调用请求参数callback即我们传入的 函数
response.write(`
    ${query.callback}.call(undefined,{
        &quot;success&quot;:true,
        &quot;left&quot;:${amount}
    })
`)
</code></pre><p>在上面的服务器代码响应第四部分中，给函数传入了参数：</p>
<pre><code>${query.callback}.call(undefined,{
    &quot;success&quot;:true,
    &quot;left&quot;:${amount}
})
</code></pre><p>这个参数包含了执行结果（成功）以及返回的数据（新的余额），这个参数的数据格式就是JSON对象，它左右的内容 <code>${query.callback}.call(undefined,</code> 与 <code>)</code>  分别是 左padding 和 右padding，这就是 <code>Json with Padding</code> 名字的由来。</p>
<p>当然，理论上这里的参数实际上并不一定需要JSON对象，只是对象能表示更多的数据，并且JSON对象能被JS解析，如果你想学习JSON，<a href="https://www.json.org/" title="这里是JSON官网" target="_blank" rel="noopener">点击去JSON官网</a>。</p>
<h2 id="JSONP与跨域"><a href="#JSONP与跨域" class="headerlink" title="JSONP与跨域"></a>JSONP与跨域</h2><p>上述讲了浏览器是怎么通过 JSONP 发送请求得到数据的，似乎还没提到怎么实现跨域。</p>
<blockquote>
<p>先来了解一下跨域：只有 <strong>协议、域名、端口</strong> 完全一样才被浏览器认为是同一个域，在一个网站中浏览器不能跨域执行另一个网站的脚本，这就是浏览器的 <strong>同源策略</strong>，也就是说你可以跨域发送请求，但是请求到的非同源数据会被拦截。浏览器的同源策略保护了数据的安全，但同时也造成了一些问题，比如一个公司有不同的子域需要互相访问，或者调用外部API，因此有时候我们就有了跨域的需求。</p>
</blockquote>
<p>那么JSONP是怎么跨域的呢？我们已经知道了是 JSONP 通过 script 发送GET请求，事实上，<strong>script 请求是不受同源策略限制的，请求到的script资源会被立即执行</strong>，JSONP就是利用了这一特性来实现跨域。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后来总结一下 JSONP 的过程：</p>
<ol>
<li>请求方动态创建一个 script 元素，src 指向响应方，并传递一个 callback=xxx 的参数；</li>
<li>响应方作出形如 callback.call(‘undefined’,‘要的数据’) 或者 callback(‘要的数据’) 的响应；</li>
<li>请求方接到响应，调用 xxx.call(‘undefined’,‘要的数据’)；</li>
<li>这样请求方就得到了他要的数据。</li>
</ol>
<ul>
<li>为什么JSONP不能发送POST请求？<br>答案：因为JONP是通过动态创建script标签实现的，script标签只能发送GET请求。</li>
</ul>
<p>最后介绍一个jQuery使用JSONP的简单方法。</p>
<pre><code>$.ajax({
    url: &quot;http://xxx.com:8002/pay&quot;,
    dataType: &quot;jsonp&quot;,
    success: function( response ) {
        if(response === &apos;success&apos;){
            amount.innerText = amount.innerText - 1
        }
    }
})
</code></pre><p>虽然名字叫 <code>ajax</code>，但是两者并没有任何联系，事实上应该叫做 <code>jsonp</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/17/JSONP/" data-id="cju6g671v00051o7l5xyw2iv7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（W）jsonp/">（W）jsonp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-position定位" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/11/position定位/" class="article-date">
  <time datetime="2018-08-11T07:29:14.000Z" itemprop="datePublished">2018-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/11/position定位/">position定位</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="取值（5）："><a href="#取值（5）：" class="headerlink" title="取值（5）："></a>取值（5）：</h2><h3 id="static："><a href="#static：" class="headerlink" title="static："></a>static：</h3><ul>
<li>元素在文档流中的正常位置</li>
<li><p>top, right, bottom, left 和 z-index 属性无效。</p>
<h3 id="relative："><a href="#relative：" class="headerlink" title="relative："></a>relative：</h3></li>
<li><p>对table元素无效</p>
</li>
<li>不脱离文档流</li>
<li>相对正常位置进行偏移</li>
<li>元素原位置会留下空白。</li>
</ul>
<h3 id="absolute："><a href="#absolute：" class="headerlink" title="absolute："></a>absolute：</h3><ul>
<li>脱离文档流，</li>
<li>相对最近非static的祖先元素的定位</li>
<li>设置margin不会与其他元素合并。</li>
</ul>
<h3 id="fixed："><a href="#fixed：" class="headerlink" title="fixed："></a>fixed：</h3><ul>
<li>固定定位</li>
<li>脱离文档流</li>
<li>相对浏览器视口定位，滚动屏幕，位置固定</li>
<li>元素祖先的transform为 非none时，相对该祖先定位</li>
</ul>
<h3 id="sticky："><a href="#sticky：" class="headerlink" title="sticky："></a>sticky：</h3><ul>
<li>粘性定位</li>
<li>相对定位relative和固定定位fixed的结合</li>
<li>对table元素无效</li>
<li>指定top、bottom、left、right后粘性定位生效，且不影响后面元素布局。</li>
<li>相对最近的BFC和块级元素祖先定位</li>
<li>举例：#one{position:sticky;top:10px}，元素初始top为50px，滚动屏幕使它top&lt;10px时，粘在top=10px的位置。</li>
</ul>
<h3 id="top、bottom、left、right"><a href="#top、bottom、left、right" class="headerlink" title="top、bottom、left、right"></a>top、bottom、left、right</h3><ul>
<li>定位元素（上、下、左、右）外边距边界与其包含块（上、下、左、右）边界之间的偏移</li>
<li>非定位元素设置此属性无效</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/11/position定位/" data-id="cju6g6735000y1o7lqg19vyge" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（C）position/">（C）position</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/（C）css布局/">（C）css布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（C）flex布局/">（C）flex布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（C）position/">（C）position</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（C）垂直居中/">（C）垂直居中</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（G）git入门/">（G）git入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（H）canvas的使用/">（H）canvas的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（H）html-常用标签/">（H）html-常用标签</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（H）html5-标签/">（H）html5-标签</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（JH）JS-this指向/">（JH）JS-this指向</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（JH）JS-普通函数及调用/">（JH）JS-普通函数及调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（JH）JS-构造函数、new做了什么/">（JH）JS-构造函数、new做了什么</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）JS-数据类型/">（J）JS-数据类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）JS-数据结构/">（J）JS-数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）Promise/">（J）Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）原型与原型链/">（J）原型与原型链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）继承/">（J）继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）自己实现-jQuery-API/">（J）自己实现-jQuery API</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（M）命令行基本命令/">（M）命令行基本命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（S）归并排序/">（S）归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（S）快速排序-js/">（S）快速排序-js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（S）排序算法-js/">（S）排序算法-js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（V）iview/">（V）iview</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（V）vue路由-视图/">（V）vue路由/视图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）HTTP（入门）/">（W）HTTP（入门）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）Session/">（W）Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）Web-Storage/">（W）Web Storage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）ajax/">（W）ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）jsonp/">（W）jsonp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）登录注册、cookie/">（W）登录注册、cookie</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/（C）css布局/" style="font-size: 10px;">（C）css布局</a> <a href="/tags/（C）flex布局/" style="font-size: 10px;">（C）flex布局</a> <a href="/tags/（C）position/" style="font-size: 10px;">（C）position</a> <a href="/tags/（C）垂直居中/" style="font-size: 10px;">（C）垂直居中</a> <a href="/tags/（G）git入门/" style="font-size: 10px;">（G）git入门</a> <a href="/tags/（H）canvas的使用/" style="font-size: 10px;">（H）canvas的使用</a> <a href="/tags/（H）html-常用标签/" style="font-size: 10px;">（H）html-常用标签</a> <a href="/tags/（H）html5-标签/" style="font-size: 10px;">（H）html5-标签</a> <a href="/tags/（JH）JS-this指向/" style="font-size: 10px;">（JH）JS-this指向</a> <a href="/tags/（JH）JS-普通函数及调用/" style="font-size: 10px;">（JH）JS-普通函数及调用</a> <a href="/tags/（JH）JS-构造函数、new做了什么/" style="font-size: 10px;">（JH）JS-构造函数、new做了什么</a> <a href="/tags/（J）JS-数据类型/" style="font-size: 10px;">（J）JS-数据类型</a> <a href="/tags/（J）JS-数据结构/" style="font-size: 10px;">（J）JS-数据结构</a> <a href="/tags/（J）Promise/" style="font-size: 10px;">（J）Promise</a> <a href="/tags/（J）原型与原型链/" style="font-size: 10px;">（J）原型与原型链</a> <a href="/tags/（J）继承/" style="font-size: 10px;">（J）继承</a> <a href="/tags/（J）自己实现-jQuery-API/" style="font-size: 10px;">（J）自己实现-jQuery API</a> <a href="/tags/（M）命令行基本命令/" style="font-size: 10px;">（M）命令行基本命令</a> <a href="/tags/（S）归并排序/" style="font-size: 10px;">（S）归并排序</a> <a href="/tags/（S）快速排序-js/" style="font-size: 10px;">（S）快速排序-js</a> <a href="/tags/（S）排序算法-js/" style="font-size: 10px;">（S）排序算法-js</a> <a href="/tags/（V）iview/" style="font-size: 10px;">（V）iview</a> <a href="/tags/（V）vue路由-视图/" style="font-size: 10px;">（V）vue路由/视图</a> <a href="/tags/（W）HTTP（入门）/" style="font-size: 10px;">（W）HTTP（入门）</a> <a href="/tags/（W）Session/" style="font-size: 10px;">（W）Session</a> <a href="/tags/（W）Web-Storage/" style="font-size: 10px;">（W）Web Storage</a> <a href="/tags/（W）ajax/" style="font-size: 10px;">（W）ajax</a> <a href="/tags/（W）jsonp/" style="font-size: 10px;">（W）jsonp</a> <a href="/tags/（W）登录注册、cookie/" style="font-size: 10px;">（W）登录注册、cookie</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/07/view路由-视图/">vue路由/视图</a>
          </li>
        
          <li>
            <a href="/2019/04/07/按需引入iview/">按需引入iview</a>
          </li>
        
          <li>
            <a href="/2018/10/21/归并排序（递归/">归并排序（递归&amp;迭代）</a>
          </li>
        
          <li>
            <a href="/2018/10/05/JS实现继承的几种方法/">JS实现继承的几种方法</a>
          </li>
        
          <li>
            <a href="/2018/09/28/JS构造函数（含new做了什么）/">JS构造函数（含new做了什么）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 lxiaox<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>