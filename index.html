<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>lxiaox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="lxiaox">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lxiaox">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lxiaox">
  
    <link rel="alternate" href="/atom.xml" title="lxiaox" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lxiaox</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JS实现继承的几种方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/05/JS实现继承的几种方法/" class="article-date">
  <time datetime="2018-10-05T12:45:37.000Z" itemprop="datePublished">2018-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/05/JS实现继承的几种方法/">JS实现继承的几种方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>类式继承（单纯的原型链继承）</li>
<li>构造继承</li>
<li>组合继承 （1，2组合）</li>
<li>寄生组合继承（3的优化）</li>
<li>extends</li>
</ol>
<h3 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h3><p>形如：</p>
<pre><code>function A(){this.a = ...}
A.prototype.aa = ...
function B(){}
B.prototype = new A()    //标记代码
//效果是 B.prototype.__proto__ = A.prototype
</code></pre><p>如此，子类B就拥有了父类A的原型（方法、属性）。</p>
<p>但是它的缺点之二是：</p>
<ol>
<li>来自原型的所有属性要被所有实例共享</li>
<li>无法在新建子类实例时，向父类构造函数传参，（只能在标记代码处传），那由B衍生的后代，这些属性值就是统一的。</li>
</ol>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>形如：</p>
<pre><code>function A(){this.a = ...}
A.prototype.aa = ...
function B(){
    A.call(this,...)    //改变作用域，使得A属性方法都赋给B（this）
}
//B无法获得A原型（上的aa），只能获得A上的属性方法（a）
</code></pre><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>很显然，上面两种各有所长，互相弥补，结合他们就得到了更好地方法–组合继承。</p>
<pre><code>function A(){this.a = ...}
A.prototype.aa = ...
function B(){
    A.call(this,...)    //构造函数
}
B.prototype = new A()        //类式（原型链）

//缺点是调用了两次A()

B.prototype.constructor = B    //本来的constructor被覆盖，重写一下
</code></pre><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><p>弥补组合继承的劣势，将类式继承改一下，如：</p>
<pre><code>//写法一
let C = function(){}
C.prototype = A.prototype
B.prototype = new C()

//C()什么也不干，要优秀一点

//写法二
B.prototype = Object.create(A.prototype)    
//b = Object.create(a)的作用就是使 b.__proto__ = a
</code></pre><h3 id="extends继承"><a href="#extends继承" class="headerlink" title="extends继承"></a>extends继承</h3><p>ES6的class实现继承，形如：</p>
<pre><code>class A{
    constructor(a){
        this.a = a
    }
}
A.prototype.aa = ...

class B extends A{
    constructor(a){
        super(a)    //子类没有this，为了继承父类的this对象
        this.a = a
    }
}

//B自动地继承A的原型
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/05/JS实现继承的几种方法/" data-id="cjni9g7r60009u87lr2j4m6xj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（J）继承/">（J）继承</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS构造函数（含new做了什么）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/28/JS构造函数（含new做了什么）/" class="article-date">
  <time datetime="2018-09-28T08:56:05.000Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/28/JS构造函数（含new做了什么）/">JS构造函数（含new做了什么）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、构造函数和普通函数的区别"><a href="#一、构造函数和普通函数的区别" class="headerlink" title="一、构造函数和普通函数的区别"></a>一、构造函数和普通函数的区别</h2><ol>
<li><p>构造函数名一般第一个字母大写：<code>Function/Number/String</code>，普通函数为驼峰式名命：<code>puTongHanShu</code></p>
</li>
<li><p>构造函数由new调用：<code>new String(&#39;abc&#39;)</code>, （abc不要忘了引号）</p>
</li>
<li><p>构造函数中可以使用this，普通函数一般不使用</p>
</li>
<li><p>构造函数一般默认不return</p>
</li>
<li><p>原型指向： </p>
<pre><code>//只写个形式表达意思
function FF(){//...}
let ff = new FF()

//那么，这个生成实例的__proto__指向构造它的函数的prototype
ff.__proto__ === FF.prototype        //true
FF.__proto__ === Function.prototype    //true    
</code></pre></li>
</ol>
<h2 id="使用new时到底做了什么"><a href="#使用new时到底做了什么" class="headerlink" title="使用new时到底做了什么"></a>使用new时到底做了什么</h2><p>构造函数可由new调用，那么new到底做了什么：</p>
<ol>
<li><p>创建临时对象，并将this指向这个临时对象</p>
</li>
<li><p>将临时对象的__proto__指向构造函数的prototype（并将构造函数Fn的prototype.constructor=Fn）</p>
</li>
<li><p>执行构造函数中的代码</p>
</li>
<li><p>返回这个临时对象</p>
</li>
</ol>
<p>代码举例：</p>
<pre><code>function F1(x){
    this.name = &apos;xiao&apos;
    console.log(x*100)
}
let f1 = new F1()     //NaN 执行了打印代码
let f2 = new F1(5)     //500

//返回对象，f1是对象
f1(5)        //报错： f1 is not a function
f1            //F1 {name: &quot;xiao&quot;}
f1.name        //&quot;xiao&quot;

//指定对象原型
f1.__proto__ === F1.prototype     //true
f1.constructor === F1             //true

//另外
F1.constructor === F1             //false
F1.constructor === Function         //true
</code></pre><h2 id="return返回情况"><a href="#return返回情况" class="headerlink" title="return返回情况"></a>return返回情况</h2><p>因为new会帮我们return 临时对象，我们就不需要自己再return，但是如果硬要return，就有如下两种情况：</p>
<ol>
<li><p><code>return 非 Object（String/Number/Boolean/Null/Undefined）</code>，仍返回新生成的（this指向的）对象；</p>
<pre><code>function F(){
    this.b = 2
    return null    //或者return 1/undefined/&quot;abc&quot;
}
let f6 = new F()

console.log(f6)   //{b:2}
</code></pre></li>
<li><p><code>return Object</code>，那就返回这个Object。</p>
<pre><code>//return 对象
    function F(){
        this.b = 2
        let o2 = {name:&apos;xiao&apos;}    //xiao不加引号错误！
        return o2    
    }
    let f5 = new F()

    console.log(f5)            //{name: &quot;xiao&quot;}
    console.log(f5.b)        //undefined
</code></pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/28/JS构造函数（含new做了什么）/" data-id="cjni9g7t8000uu87li54eotap" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（JH）JS-构造函数、new做了什么/">（JH）JS-构造函数、new做了什么</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS普通函数及调用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/28/JS普通函数及调用/" class="article-date">
  <time datetime="2018-09-28T05:00:35.000Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/28/JS普通函数及调用/">JS普通函数及调用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>想想还是决定把普通函数、构造函数分两篇总结。</p>
<h2 id="一、声明（包括函数名情况）"><a href="#一、声明（包括函数名情况）" class="headerlink" title="一、声明（包括函数名情况）"></a>一、声明（包括函数名情况）</h2><h3 id="方法一：具名函数"><a href="#方法一：具名函数" class="headerlink" title="方法一：具名函数"></a>方法一：具名函数</h3><pre><code>function f1(x){
    console.log(x)
}

//函数名
f1.name === &apos;f1&apos;    //true
f1.name === &apos;f1&apos;    //true
f1.name === &apos;f1&apos;    //true
</code></pre><h3 id="方法二：匿名函数"><a href="#方法二：匿名函数" class="headerlink" title="方法二：匿名函数"></a>方法二：匿名函数</h3><pre><code>let f2
f2 = function(x){
    console.log(x)
}

//函数名
f2.name === &apos;f2&apos;    //true
f2.name === &apos;f2&apos;    //true
f2.name === &apos;f2&apos;    //true
</code></pre><h3 id="方法三：具名函数赋值"><a href="#方法三：具名函数赋值" class="headerlink" title="方法三：具名函数赋值"></a>方法三：具名函数赋值</h3><pre><code>let f3 = function f4(){
    console.log(&apos;f3&apos;)
}

//函数名
f3.name === &apos;f4&apos;    //true
f3.name === &apos;f4&apos;    //true
f3.name === &apos;f4&apos;    //true

//注意 
f4.name        //报错：f4 is not defined
f4.name        //报错：f4 is not defined
f4.name        //报错：f4 is not defined
</code></pre><h3 id="方法四：使用window-Function"><a href="#方法四：使用window-Function" class="headerlink" title="方法四：使用window.Function"></a>方法四：使用window.Function</h3><pre><code>let f5 = new Function(&apos;x&apos;,&apos;y&apos;,&apos;return x+y&apos;)
f5(1,2)        //3

//函数名
f5.name        //&apos;annoymous&apos;  匿名的
f5.name        //&apos;annoymous&apos;  匿名的
f5.name        //&apos;annoymous&apos;  匿名的
</code></pre><h3 id="方法五：箭头函数"><a href="#方法五：箭头函数" class="headerlink" title="方法五：箭头函数"></a>方法五：箭头函数</h3><pre><code>(x)=&gt;{console.log(x)}

let f6 = (x)=&gt;{console.log(x)}

//箭头函数只有一句返回时，可以省略大括号和return
let f6 = (x,y)=&gt;{return x + y}
let f6 = (x,y)=&gt; x + y

//箭头函数只有一个参数时，可以省略小括号
let f6 = (x)=&gt;{return x*2}
let f6 = x =&gt; x*2
</code></pre><h2 id="二、函数返回"><a href="#二、函数返回" class="headerlink" title="二、函数返回"></a>二、函数返回</h2><ul>
<li>函数需要return；</li>
<li>没有return 就默认 return undefined。</li>
</ul>
<h2 id="三、函数调用"><a href="#三、函数调用" class="headerlink" title="三、函数调用"></a>三、函数调用</h2><ol>
<li><p>使用 <code>fn(x1,x2)</code></p>
</li>
<li><p>作为对象方法 <code>obj.xx.fn(x,y)</code></p>
</li>
<li><p>call()</p>
<pre><code> fn.call(asThis,x1,x2,...)

//call第一个参数是this，后面的做真正的参数。

function ff(x,y,z){return x+y+z}
ff.call(1,2,2,2)    //6
</code></pre></li>
<li><p>apply()</p>
<pre><code>fn.apply(asThis,[x1,x2,...])

//apply区别与call就是它第二个参数接受数组，
//我们需要把剩下的参数作为一个数组传递。

function ff(x,y,z){return x+y+z}
ff.apply(1,[2,2,2])    //6
</code></pre></li>
</ol>
<ol start="5">
<li><p>bind()（绑定不调用）</p>
<pre><code>fn.bind(asThis,[x1,x2,...])

//bind方法不会调用函数，而是生成一个绑定函数(而且已经传好参数，不可改)
//它的参数同call一致

function ff(x,y,z){return x+y+z}
let mm = ff.bind(1,2,2,2)
mm()    //6    
mm(1,1,1)    //6，没有变
mm.call(1,3,3,3)    //6，新传的参数不起作用
</code></pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/28/JS普通函数及调用/" data-id="cjni9g7rk000fu87lojzvuyyx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（JH）JS-普通函数及调用/">（JH）JS-普通函数及调用</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS中的this指向" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/28/JS中的this指向/" class="article-date">
  <time datetime="2018-09-28T03:17:25.000Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/28/JS中的this指向/">JS中的this指向</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="使用call的情况"><a href="#使用call的情况" class="headerlink" title="使用call的情况"></a>使用call的情况</h1><p>要知道什么是call的实质：JavaScript模仿Java（抱大腿），所以也要弄一个this，JS之父就把<strong>call第一个参数</strong>作为this。</p>
<pre><code>function fn(){console.log(this)}
fn()             //window
fn.call(1)         //Number{1}
fn.call(&apos;abc&apos;)     //String {&quot;abc&quot;}
</code></pre><p>call把第一个参数作为this，后面的参数作为函数的参数。</p>
<pre><code>function fn(x,y){console.log(x,y)}
fn(1,2)            //3
fn.call(undefined,1,2)    //3，this是undefined，1，2作为参数
</code></pre><p>正是因为this实质上是call第一个参数，那么我们想确定this，看各种API源码是最靠谱的。</p>
<p>既然知道this是call第一个参数，那么关于this的问题就简单了，接下来看：通过改写为call调用的方式确定this</p>
<h1 id="一般分类（注意：以下都是不使用call强行改this的情况，或者说默认call的情况）"><a href="#一般分类（注意：以下都是不使用call强行改this的情况，或者说默认call的情况）" class="headerlink" title="一般分类（注意：以下都是不使用call强行改this的情况，或者说默认call的情况）"></a>一般分类（注意：以下都是不使用call强行改this的情况，或者说默认call的情况）</h1><h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p>全局作用域中调用this，那么this指向window</p>
<h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><ol>
<li><p>在全局的函数中（两种情况）</p>
<pre><code>//第一种:window
function f1(){
    console.log(this)
}    
f1()    //window对象

//第二种：严格模式是undefined
function f2(){
    &apos;use strict&apos;
    console.log(this)
}
f2()    //undefined
</code></pre></li>
</ol>
<p>转换为call：</p>
<pre><code>f1.call()    ||  f2.call()

//这里的call没有传第一个参数，也就是this为undefined，为什么是window呢

//浏览器规定context为null或undefined，

//那么context就是window对象，严格模式是undefined
</code></pre><h2 id="三、对象调用"><a href="#三、对象调用" class="headerlink" title="三、对象调用"></a>三、对象调用</h2><p>之前看到有人说：“要搞懂this只需理解：函数中this在定义时是不能确定的，只有在执行时才知道，因为函数this永远指向最后调用这个函数的对象”，这呢，正是因为源是把这个调用对象作为call第一个参数啊！</p>
<pre><code>let o1 = {
    a: 1,
    f3: function f3(){
        console.log(this)
    }
}

//1、用o1调用
o1.f3()   //{a: 1, f3: ƒ}  this指向o1
//即
o1.f3.call(o1)

//2、不用o1
let f4 = o1.f3
f4()      //window对象   this指向window
//即
f4.call()
</code></pre><h2 id="四、构造函数"><a href="#四、构造函数" class="headerlink" title="四、构造函数"></a>四、构造函数</h2><p>首先要知道：构造函数生成一个临时对象AAA，把this指向AAA。</p>
<p>一、正常情况下，构造函数会return临时对象AAA，那么构造实例就是AAA，this也就<strong>指向构造出的实例</strong>，</p>
<pre><code>function F(){
    this.b = 2
}
let f5 = new F()
console.log(f5.b)    //2, 所以f5上是有属性 b 的，也就是构造时this指向f5
</code></pre><p>二、非常情况（如果在构造函数有return）</p>
<ol>
<li><p>return 一个对象 BBB，那么构造实例就为BBB，this仍指向构造函数生成的临时对象AAA，所以this<strong>并不指向构造实例</strong>。</p>
<pre><code>//return 对象
function F(){
    this.b = 2
    let o2 = {name:&apos;xiao&apos;}    //xiao不加引号错误！
    return o2    
}
let f5 = new F()

console.log(f5)            //{name: &quot;xiao&quot;}
console.log(f5.b)        //undefined
</code></pre></li>
<li><p>return 非对象，包括null，虽然 typeof(null) === ‘object’，那么新构造的实例还是this指向的临时对象。</p>
</li>
</ol>
<pre><code>function F(){
    this.b = 2
    return null    //或者return 1/undefined/&quot;abc&quot;
}
let f6 = new F()

console.log(f6)   //{b:2}
</code></pre><p>到这里，我发现这些非常情况似乎已经不是this指向问题了，而是new的返回问题了。</p>
<p>所以记住，<strong>构造函数的this指向构造实例</strong> 就OK</p>
<p><a href="">关于new的博客</a></p>
<h2 id="五、箭头函数"><a href="#五、箭头函数" class="headerlink" title="五、箭头函数"></a>五、箭头函数</h2><p>箭头函数不改变this，箭头函数里面的this就是它外面的this，可以理解为<strong>将当前的this作为call第一个参数</strong>。</p>
<pre><code>let o3 = {
    name: &apos;ooo3&apos;,
    f7: ()=&gt;{console.log(this)}
}

o3.f7()        //window对象
//按照上面‘对象调用’的说法，改为call似乎应该是
o3.f7.call(o3)

//但是箭头函数不改变this，所以应该是：
o3.f7.call(this)
//当前this就是window对象
</code></pre><h2 id="最后总结，this就是call第一个参数，call调用才是正常的模式，不使用call调用的，想要确定this都只能看底层调用源码怎么写了。"><a href="#最后总结，this就是call第一个参数，call调用才是正常的模式，不使用call调用的，想要确定this都只能看底层调用源码怎么写了。" class="headerlink" title="最后总结，this就是call第一个参数，call调用才是正常的模式，不使用call调用的，想要确定this都只能看底层调用源码怎么写了。"></a>最后总结，this就是call第一个参数，call调用才是正常的模式，不使用call调用的，想要确定this都只能看底层调用源码怎么写了。</h2><p>this就是call第一个参数，写完这篇文章，成功洗脑 √</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/28/JS中的this指向/" data-id="cjni9g7rb000bu87l6c17xvx6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（JH）JS-this指向/">（JH）JS-this指向</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-总结垂直居中" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/24/总结垂直居中/" class="article-date">
  <time datetime="2018-09-24T05:49:26.000Z" itemprop="datePublished">2018-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/24/总结垂直居中/">垂直居中总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、最常用的"><a href="#1、最常用的" class="headerlink" title="1、最常用的"></a>1、最常用的</h3><ol>
<li><p>parent: height不写死，</p>
</li>
<li><p>child：padding-top / padding-bottom设为同值。</p>
</li>
</ol>
<h2 id="当parent：height写死时："><a href="#当parent：height写死时：" class="headerlink" title="当parent：height写死时："></a>当parent：height写死时：</h2><h3 id="2、tabel-或-display-table"><a href="#2、tabel-或-display-table" class="headerlink" title="2、tabel 或 display: table"></a>2、tabel 或 display: table</h3><ol>
<li><p>直接使用table</p>
<pre><code>&lt;table class=&quot;parent&quot;&gt;
  &lt;tr&gt;&lt;td class=&quot;child&quot;&gt;这里内容自动垂直居中&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre></li>
<li><p>利用div伪造table</p>
<pre><code>&lt;div class=&quot;parent&quot;&gt;
  &lt;div class=&quot;child&quot;&gt; 垂直居中内容 &lt;/div&gt;
&lt;/div&gt;

.parent{
    height: 300px; 
    display : table-cell;
    vertical-align: middle;
}
.child{}
</code></pre></li>
</ol>
<h3 id="3、加span或伪类-高度100"><a href="#3、加span或伪类-高度100" class="headerlink" title="3、加span或伪类(高度100%)"></a>3、加span或伪类(高度100%)</h3><ol>
<li>添加span</li>
</ol>
<pre><code>&lt;div class=&quot;parent&quot;&gt;
  &lt;span class=&quot;before&quot;&gt;&lt;/span&gt;
  &lt;div class=&quot;child&quot;&gt; 垂直居中内容 &lt;/div&gt;
  &lt;span class=&quot;after&quot;&gt;&lt;/span&gt;
&lt;/div&gt;

//
.before{
    display: inline-block;
    height: 100%;
    vertical-align: middle
}
.child{
    vertical-align: middle
}
</code></pre><ol start="2">
<li><p>不需要加span，直接利用伪类</p>
<pre><code>.parent:before,
.parent:after{
    content:&apos;&apos;;
    display:inline-block;
    height: 100%;
    vertical-align: middle;
}
.child{
    vertical: middle;
}
</code></pre></li>
</ol>
<h3 id="4、child绝对定位-偏移量"><a href="#4、child绝对定位-偏移量" class="headerlink" title="4、child绝对定位+偏移量"></a>4、child绝对定位+偏移量</h3><pre><code>&lt;div class=&quot;parent&quot;&gt;
    &lt;div class=&quot;child&quot;&gt; 垂直居中内容 &lt;/div&gt;
&lt;/div&gt;

.parent{height:300px;position:relative;}

//使用margin偏移，child高度的50%
.child{
    height: 100px;
    position: absolute;
    top: 50%;
    margin-top: -50px;
}

//使用transform，可以不用知道child高度
.child{
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
}
</code></pre><p>同样适用于水平居中。</p>
<h3 id="5、child-绝对定位-margin-auto"><a href="#5、child-绝对定位-margin-auto" class="headerlink" title="5、child 绝对定位 + margin: auto"></a>5、child 绝对定位 + margin: auto</h3><pre><code>.parent{
    position: relative;
    height: 300px;
}
.child{
    position: absolute;
    top: 0;
    bottom: 0;
    margin: auto;
    height: 100px;
    //不设置child height会拉伸
}
</code></pre><p>同样适用水平居中。</p>
<h3 id="6、flex-弹性盒子布局"><a href="#6、flex-弹性盒子布局" class="headerlink" title="6、flex 弹性盒子布局"></a>6、flex 弹性盒子布局</h3><pre><code>.parent{
    height: 300px;
    display: flex;
    align-items: center;
}
.child{}
</code></pre><p>我的博客链接：</p>
<p><a href="https://lxiaox.github.io/2018/09/21/flex%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">flex布局总结</a></p>
<p><a href="https://lxiaox.github.io/2018/05/27/css%E5%B8%83%E5%B1%80/" target="_blank" rel="noopener">css布局</a></p>
<p>本文总结自<a href="https://jscode.me/t/topic/1936" target="_blank" rel="noopener">七种方式实现垂直居中</a> （内含具体代码实现）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/24/总结垂直居中/" data-id="cjni9g7vm0021u87ld006n544" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（C）垂直居中/">（C）垂直居中</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-正确快速排序学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/23/正确快速排序学习/" class="article-date">
  <time datetime="2018-09-23T13:26:17.000Z" itemprop="datePublished">2018-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/23/正确快速排序学习/">快速排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="快速排序（又名划分交换排序-简称快排）"><a href="#快速排序（又名划分交换排序-简称快排）" class="headerlink" title="快速排序（又名划分交换排序,简称快排）"></a>快速排序（又名划分交换排序,简称快排）</h2><ul>
<li>基本思想：利用分治法的思想，将一个序列分为两个子序列，对子序列递归地排序。</li>
<li>时间复杂度：O(nlogn),最坏：O(n^2)</li>
<li>步骤：<ol>
<li>任找一个元素作为基准值</li>
<li>将所有比基准值小的元素放在基准值前面；所有大于基准值的放在它右边；等于基准值的元素放前后都可。</li>
<li>递归得对子数组进行上述操作。</li>
<li>合并子数组</li>
</ol>
</li>
</ul>
<h2 id="JS-代码-v2-："><a href="#JS-代码-v2-：" class="headerlink" title="JS 代码(v2)："></a>JS 代码(v2)：</h2><pre><code>Array.prototype.quicksort = function(){
  quick(this, 0, this.length-1)
}
function quick(arr,left,right){
  if(left &gt;= right) return
  let basis = arr[left]
  let i = left, j = right
  while(i!=j){ 
    while(arr[j]&gt;=basis &amp;&amp; i&lt;j) j-=1     //标记代码
    while(arr[i]&lt;=basis &amp;&amp; i&lt;j) i+=1    

    if(i &lt; j){
      [arr[i],arr[j]] = [arr[j],arr[i]]  
    }
  }
  [arr[left],arr[i]] = [arr[i],arr[left]]
  quick(arr,left,i-1)
  quick(arr,i+1,right)
}
var arr = [2,8,5,4,3,9,0.-1,3,2]
arr.quicksort()
console.log(arr)  //[-1, 2, 2, 3, 3, 4, 5, 8, 9]
</code></pre><h4 id="另附上错误版本代码"><a href="#另附上错误版本代码" class="headerlink" title="另附上错误版本代码:"></a>另附上错误版本代码:</h4><p>（空间复杂度增加到O(nlogn)，本应是O(1) ）</p>
<pre><code>Array.prototype.quicksort = function(){
  if(this.length &lt; 2) return this
  let basis = this[0]
  let left=[],right=[]
  for(let i = 1; i&lt;this.length; i++){
    if(this[i]&lt;basis) left.push(this[i])
    else right.push(this[i])
  }
  return left.quicksort().concat(basis,right.quicksort())
}

let arr = [6,5,0,1,32,5,8,3,4,9]
let arr2 = arr.quicksort()
console.log(arr2)  //[0, 1, 3, 4, 5, 5, 6, 8, 9, 32]
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/23/正确快速排序学习/" data-id="cjni9g7uh001du87lkl0v3fj0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（S）快速排序-js/">（S）快速排序-js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-flex布局总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/21/flex布局总结/" class="article-date">
  <time datetime="2018-09-21T13:47:00.000Z" itemprop="datePublished">2018-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/21/flex布局总结/">flex布局总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天发现flex布局很多没有经常使用的属性，特来总结。</p>
<p>弹性盒子（Flex Box）是CSS3新出的一种布局模式。它主要是将容器内元素进行合理排列、对齐以及分配空白空间。它的优点是响应式布局，使得页面适用于不同设备，不同大小的屏幕。</p>
<p>方法：在父元素上添加样式:</p>
<pre><code>.parent{
    display: flex;
}
</code></pre><p>或者：</p>
<pre><code>.parent{
    display: inline-flex;
}
</code></pre><p>如此使该父容器中的子元素按横向排列（默认）。</p>
<p><a href="http://flexboxfroggy.com/#zh-cn" target="_blank" rel="noopener">青蛙跳荷叶的游戏网站</a> 帮助学习flex布局各种属性。</p>
<h3 id="flex-direction-选择子元素排列方向"><a href="#flex-direction-选择子元素排列方向" class="headerlink" title="flex-direction 选择子元素排列方向"></a>flex-direction 选择子元素排列方向</h3><p>该属性有四个值：</p>
<ol>
<li>row：横向，从左至右。(父子左对齐，超出在右边）</li>
</ol>
<ul>
<li>row-reverse：横向：从右至左。(父子右对齐，超出在左边）</li>
<li>column：纵向，从上至下。（父子上对齐，超出在下面）</li>
<li>column-reverse：纵向，从下至上。（父子下对齐，超出在上面）</li>
</ul>
<p>另：<code>body { direction: rtl; }</code>也可以修改排列方向为从右至左。</p>
<h3 id="justify-content-子元素沿容器主轴线对齐方向"><a href="#justify-content-子元素沿容器主轴线对齐方向" class="headerlink" title="justify-content 子元素沿容器主轴线对齐方向"></a>justify-content 子元素沿容器主轴线对齐方向</h3><p>五个属性值：</p>
<ol>
<li>flex-start: 元素紧挨行头。</li>
</ol>
<ul>
<li>flex-end: 元素紧挨行尾。 </li>
<li>center: 元素靠向容器中间。</li>
<li>space-between:元素之间保持相等的距离。</li>
<li>space-around:元素周围保持相等的距离。（区别在于多了首尾两边的空白）</li>
</ul>
<p>这时主轴线可以理解为 <code>第一个元素</code> 到 <code>最后一个元素</code> 连线（一行）的方向。</p>
<p>根据flex-direction的取值不同，行头行尾随之变化。</p>
<p>比如：row：行头在左边， row-reverse：行头在右边。</p>
<p>总之：行头在第一个元素所在侧，行尾是最后一个元素那侧。</p>
<h3 id="align-items-子元素沿容器侧轴对齐方向"><a href="#align-items-子元素沿容器侧轴对齐方向" class="headerlink" title="align-items 子元素沿容器侧轴对齐方向"></a>align-items 子元素沿容器侧轴对齐方向</h3><p>侧轴与主轴垂直。<br>属性值如下：</p>
<ol>
<li>flex-start：子元素靠侧轴起始位置。（上或左）</li>
<li>flex-end：子元素靠侧轴结束位置。（下或右）</li>
<li>center：在侧轴方向居中。（如果溢出是同时向两边溢出）</li>
<li>baseline：元素在容器的基线位置显示。</li>
<li>stretch: 元素被拉伸以填满整个容器。（也受’min/max-width/height’属性的限制。）</li>
</ol>
<h3 id="flex-wrap-属性"><a href="#flex-wrap-属性" class="headerlink" title="flex-wrap 属性"></a>flex-wrap 属性</h3><p>各个值解析:</p>
<ol>
<li>nowrap：（默认），子元素在同一行。可能会溢出。</li>
<li>wrap: 溢出部分会换行。</li>
<li>wrap-reverse：行之间排列反转。比如第一行在最下面。</li>
</ol>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow:"></a>flex-flow:</h3><p>是flex-direction和flex-wrap的简写</p>
<p><code>如：flex-flow: column wrap</code></p>
<h3 id="align-content-属性"><a href="#align-content-属性" class="headerlink" title="align-content 属性"></a>align-content 属性</h3><ol>
<li>stretch：（默认）各行将会伸展以占用剩余的空间。</li>
<li>flex-start： 各行向容器的起始位置堆叠。</li>
<li>flex-end：各行向容器的结束位置堆叠。</li>
<li>center：各行向弹性盒容器的中间位置堆叠。</li>
<li>space-between：行与行之间保持相等的距离。</li>
<li>space-around：行与行周围保持相等的距离。</li>
</ol>
<h2 id="以上都是定义在父元素身上的属性，现在来看子元素："><a href="#以上都是定义在父元素身上的属性，现在来看子元素：" class="headerlink" title="以上都是定义在父元素身上的属性，现在来看子元素："></a>以上都是定义在父元素身上的属性，现在来看子元素：</h2><h3 id="order-排列顺序"><a href="#order-排列顺序" class="headerlink" title="order 排列顺序"></a>order 排列顺序</h3><p>用整数值表示排列顺序，可以为负数，小的排在前面。</p>
<ul>
<li>当几个元素为同值，他们之间按原顺序。</li>
</ul>
<p>比如将第三个子元素排在最前面:</p>
<p> <code>.child3{ order: -1; } //其他子元素不设置</code></p>
<p>为什么设为 -1 ？</p>
<p>将child3设为order：0 时，它仍排在child1、child2后面。可以猜测默认所有元素 order 值为 0。</p>
<h3 id="margin-auto"><a href="#margin-auto" class="headerlink" title="margin: auto"></a>margin: auto</h3><ol>
<li>比如某一个子元素设置：<code>margin-left: auto</code>,那么所有空白都集中在它左侧。</li>
<li>所有子元素设置为：<code>margin: auto</code>,可以实现所有元素居中。</li>
</ol>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>值同align-items，区别在于：align-items针对所有子元素，align-selgf只管一个。</p>
<ol>
<li>auto</li>
<li>flex-start</li>
<li>flex-end</li>
<li>center</li>
<li>baseline</li>
<li>stretch</li>
</ol>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>flex三个属性：</p>
<ol>
<li>flex-grow：扩展比率。值必须为无单位数。默认为1。负值无效。</li>
<li>flex-shrink：收缩比率。值必须为无单位数。默认为1。负值无效。</li>
<li>flex-basis：基本宽度/高度。值必须为<strong>各种</strong>有效宽度值（0必须带单位）。默认为0%。</li>
</ol>
<h5 id="所谓扩展是指子元素伸展占领空白区的比率；收缩也是针对溢出的宽高。"><a href="#所谓扩展是指子元素伸展占领空白区的比率；收缩也是针对溢出的宽高。" class="headerlink" title="所谓扩展是指子元素伸展占领空白区的比率；收缩也是针对溢出的宽高。"></a>所谓扩展是指子元素伸展占领空白区的比率；收缩也是针对溢出的宽高。</h5><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p>1、<code>flex: [flex-grow] [flex-shrink] [flex-basis];</code></p>
<pre><code>.child1{ flex: 1 0 30px; }

//child1可扩展，可收缩，基值30px（一般大于或等于30px）
</code></pre><p>2、</p>
<ol>
<li><code>flex: auto</code>: 计算值为 1 1 auto</li>
</ol>
<ul>
<li><code>flex: initial</code>: 计算值为 0 1 auto</li>
<li><code>flex: none</code>：计算值为 0 0 auto</li>
<li><code>flex: inherit</code>：从父元素继承</li>
</ul>
<h4 id="单-双值："><a href="#单-双值：" class="headerlink" title="单/双值："></a>单/双值：</h4><ol>
<li>三个值按顺序赋给相应属性；</li>
<li>flex只有一个数会作为flex-grow；</li>
<li>两个数第一个给flex-grow，第二个给flex-shrink；</li>
<li>一个数一个宽度值：数给flex-grow，宽度给flex-basis。</li>
</ol>
<p>举例：</p>
<pre><code>.child1{
    flex: 2; //扩展，将空白部分的2/4分配给child1
}
.child2{
    flex: 1; //扩展，将空白部分的1/4分配给child1
}
.child3{
    flex: 1; //扩展，将空白部分的1/4分配给child1
}
//并不表示child1宽度是child2或child2的两倍。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/21/flex布局总结/" data-id="cjni9g7tr000zu87lm45zv7ch" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（C）flex布局/">（C）flex布局</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Promise学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/07/Promise学习/" class="article-date">
  <time datetime="2018-09-07T11:40:44.000Z" itemprop="datePublished">2018-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/07/Promise学习/">Promise学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="什么是-Promise？"><a href="#什么是-Promise？" class="headerlink" title="什么是 Promise？"></a>什么是 Promise？</h1><p>Promise作为ES6最重要的特性之一，它本身是一个构造函数，并拥有<code>resolve</code>、 <code>reject</code>、 <code>all</code>、 <code>race</code> 等方法。</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-8/100325.jpg" alt="打印Promise"></p>
<h5 id="Promise-对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。"><a href="#Promise-对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。" class="headerlink" title="Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。"></a>Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。</h5><h3 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h3><p><code>new Promimse( function(resolve, reject) {} )</code></p>
<p>Promise构造函数接受一个函数，这个函数的参数为<code>resolve</code>和<code>reject</code>，<code>resolve</code>将<code>Promise</code>状态改为<code>fulfilled</code>,<code>reject</code>将其状态改为<code>rejected</code>，promise会根据不同状态执行不同操作。</p>
<h3 id="一个Promise有以下几种状态："><a href="#一个Promise有以下几种状态：" class="headerlink" title="一个Promise有以下几种状态："></a>一个Promise有以下几种状态：</h3><ul>
<li><code>pending</code>：初始状态，不成功也没失败</li>
<li><code>fulfilled</code>：表示操作成功完成</li>
<li><code>rejected</code>：表示操作失败</li>
<li><code>settled</code>：完成状态，fulfilled和rejected的统称</li>
</ul>
<p><code>pending</code>状态的Promise可能触发<code>fulfilled</code>状态，并传递一个值给成功之后的操作；也可能触发<code>rejected</code>状态，并传递失败信息或失败原因给失败之后的操作。</p>
<h1 id="改变状态之后的操作："><a href="#改变状态之后的操作：" class="headerlink" title="改变状态之后的操作："></a>改变状态之后的操作：</h1><p>打印Promise对象可以看到，它的原型方法<code>then()</code>、<code>catch()</code>、<code>finally()</code>，这些方法会表明Promise操作完成之后要做的事情。</p>
<h3 id="1、Promise-prototype-then-onFulfilled-onRejected"><a href="#1、Promise-prototype-then-onFulfilled-onRejected" class="headerlink" title="1、Promise.prototype.then(onFulfilled, onRejected)"></a>1、Promise.prototype.then(onFulfilled, onRejected)</h3><p> then()方法最多接受两个参数，即成功之后调用的回调函数，和失败之后调用的回调函数，同时它返回一个Promise对象，使得Promise().then().then()这样的链式操作得以实现。</p>
<pre><code>promise.then(
    function(value){
        //如果成功...
    },
    function(reason){
        //失败...
    }
)
</code></pre><p><code>then()</code>方法也可只接受成功的回调函数，那么失败情况就会由<code>catch()</code>方法处理。</p>
<h3 id="2、Promise-prototype-catch-onRejected"><a href="#2、Promise-prototype-catch-onRejected" class="headerlink" title="2、Promise.prototype.catch(onRejected)"></a>2、Promise.prototype.catch(onRejected)</h3><p> <code>catch()</code>方法处理拒绝也就是失败的情况，同时返回一个Promise对象。</p>
<pre><code>promise.catch(
    function(reason){
        //失败...
    }
)
</code></pre><h3 id="3、Promise-prototype-finally"><a href="#3、Promise-prototype-finally" class="headerlink" title="3、Promise.prototype.finally()"></a>3、Promise.prototype.finally()</h3><p> <code>finall()</code>也返回一个Promise对象，then()和catch()执行之后都会执行finally()，可以避免重复书写同样的代码。</p>
<pre><code>promise.finally(
    function(){
        //成功和失败都会执行...
    }
)
</code></pre><p>要注意，就算是失败的Promise经过<code>then()</code>、<code>catch()</code>处理，返回的新的Promise状态是<strong>成功</strong>的，除非再次处理（<code>then</code>、<code>catch</code>）失败。</p>
<p>同时形如<code>promise.then().then().then().catch()</code>，所有的失败情况都由最后的<code>catch()</code>处理，一旦某个地方失败，就会顺着操作链寻找到失败的回调函数。</p>
<h2 id="那么现在就可以写一个Promise了"><a href="#那么现在就可以写一个Promise了" class="headerlink" title="那么现在就可以写一个Promise了"></a>那么现在就可以写一个Promise了</h2><p>先封装一个函数：</p>
<pre><code>function test(num){
    var p = new Promise(function(resolve, reject){
        //设置延时，进行异步操作
        setTimeout(function(){
           if(num === 66){
               console.log(&apos;顺利完成&apos;)
               resolve(&apos;66大顺，成功&apos;) //resolve将状态改为fulfilled，完成
           }else{
               console.log(&apos;失败&apos;)
               reject(&apos;不顺利，失败了&apos;)  //reject将状态改为rejected，拒绝
           }
        }, 3000)
    })
    return p
}
</code></pre><p>在上述代码中，我们封装了一个函数，这个函数返回一个promise对象。我们定义了一个异步操作，就是判断数值是否为66，等于成功，不等于就失败。</p>
<p>为什么要封装函数？因为在new一个Promise对象时，传进去的函数会执行，封装函数之后我们就可以在调用函数时再执行它。</p>
<p>接下来就可以调用函数，进行下一步操作：</p>
<pre><code>//成功的情况：
test(66).then(function(value){
    console.log(&apos;成功信息：&apos;)
    console.log(value)
}).catch(function(reason){
    console.log(&apos;失败信息：&apos;)
    console.log(reason)
})
</code></pre><p>成功结果截图，3s之后输出：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-8/35816019.jpg" alt="成功结果"></p>
<pre><code>//失败的情况：
test(55).then(function(value){
    console.log(&apos;成功信息：&apos;)
    console.log(value)
}).catch(function(reason){
    console.log(&apos;失败信息：&apos;)
    console.log(reason)
})
</code></pre><p>失败结果截图，3s之后输出：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-8/48159739.jpg" alt="失败结果"></p>
<h1 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h1><h3 id="1、Promise-resolve-value"><a href="#1、Promise-resolve-value" class="headerlink" title="1、Promise.resolve(value)"></a>1、Promise.resolve(value)</h3><p><code>resolve()</code>方法返回一个给定值解析之后的Promise对象。其中又分为几种情况：</p>
<p>1、如果传入的值本身是一个Promise对象，那么就返回这个Promise对象</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-8/58265184.jpg" alt="传入Promise对象"></p>
<p>如图传入Promise对象为：test(55)，它的状态是失败，resolve()的返回值就是这个失败状态的promise，因此会调用失败的回调输出failed。</p>
<p>2、如果传入的值是个thenable对象，即带有then方法，那么返回的是then之后最终状态的promise。</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-8/84989719.jpg" alt="传入thenable"></p>
<p>如图传入<code>test(55).then().catch()</code>，虽然<code>test(55)</code>是失败的，但是它经过<code>catch()</code>处理，最后返回的状态是成功，所以<code>resolve()</code>最后的<code>then()</code>会输出<code>success</code>。</p>
<p>3、如果传入的是其他值，那么就以成功状态返回Promise。</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-8/24130485.jpg" alt="传入其他值"></p>
<p>如图传入<code>‘abcde’</code>，最终状态是成功，输出<code>success</code>。</p>
<h3 id="2、Promise-reject-reason"><a href="#2、Promise-reject-reason" class="headerlink" title="2、Promise.reject(reason)"></a>2、Promise.reject(reason)</h3><p><code>reject()</code>方法返回一个带有拒绝原因参数的Promise对象。</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-8/43684756.jpg" alt="reject1"></p>
<p>从上图可以看出这里的拒绝原因就是字符串‘abcde’本身。</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-8/47409228.jpg" alt="reject2"></p>
<p>这里的原因是Error: failed。</p>
<h3 id="3、Promise-all-iterable"><a href="#3、Promise-all-iterable" class="headerlink" title="3、Promise.all(iterable)"></a>3、Promise.all(iterable)</h3><p><code>all()</code>方法返回一个Pomise对象，它传入的参数（iterable译为可迭代的）是promise的数组，即多个promise，只有所有的Promise对象都为成功状态，<code>all()</code>才会返回成功状态的Promise对象。如果有一个失败，那么<code>all()</code>返回失败promise，且失败原因就是第一个失败promise的失败原因。</p>
<pre><code>var promise1 = Promise.resolve(66)
var promise2 = Promise.reject(55)
var promise3 = &apos;abcde&apos;
var promise4 = new Promise(function(resolve, reject) {
    setTimeout(()=&gt;{resolve(&apos;success&apos;)}, 300)
})
var promise5 = new Promise(function(resolve, reject) {
    setTimeout(()=&gt;{reject(&apos;failed&apos;)}, 300)
})
//promise4和promise5被创建的时候，传入的函数就开始执行，我验证时是直接在控制台粘贴本段所有代码再执行，影响不大，但最好封装成一个函数，将时间延迟增长至3s:
var promise4 =function() {
    return new Promise(function (resolve, reject) {
        setTimeout(() =&gt; {
            resolve(&apos;success&apos;)
        }, 3000)
    })
}
var promise5 =function() {
    return new Promise(function (resolve, reject) {
        setTimeout(() =&gt; {
            reject(&apos;failed&apos;)
        }, 3000)
    })
}

function onFulfilled(value) {
    console.log(&apos;成功：&apos;)
    console.log(value)
}
function onRejected(reason){
    console.log(&apos;失败：&apos; + reason)
}

//开始测试：
Promise.all([promise1, promise2, promise3]).then(onFulfilled,onRejected)
    //输出“失败：55”，因为promise1成功，promise2失败

Promise.all([promise5(), promise2, promise3]).then(onFulfilled,onRejected)
    //输出“失败：55”，因为promise2比promise5先处理完成，这里是看处理时间
    //promise5设置了延时，这里要注意本人之前犯的错误：setTimeout(resolve(&apos;success&apos;),300)
    //resolve(&apos;success&apos;)没有包在函数里，导致代码直接执行（原因同eval()）没有延迟，最终输出为“失败：failed”，得出错误的结论

Promise.all([promise1, promise3, promise4()]).then(onFulfilled,onRejected)
    //过3s输出：Array [66, &quot;abcde&quot;, &quot;success&quot;]，因为promise4有延时，等全部promise为成功状态时就会将值组成数组一起输出
</code></pre><h3 id="3、Promise-race-iterable"><a href="#3、Promise-race-iterable" class="headerlink" title="3、Promise.race(iterable)"></a>3、Promise.race(iterable)</h3><p><code>race()</code>方法返回一个Promise对象，它与<code>all()</code>不同之处在于一旦迭代器中某个proise完成或拒绝，那么就返回完成或拒绝的Promise对象。</p>
<pre><code>//沿用上面的代码
Promise.race([promise1, promise2, promise3])
    .then(onFulfilled,onRejected)
//输出“成功：66”，第一个成功就返回成功值66。

Promise.race([promise5(), promise2, promise3])
    .then(onFulfilled,onRejected)
//输出“失败：55”，因为promise5有延时，所以promise2最先处理完。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/07/Promise学习/" data-id="cjni9g7tc000vu87la2sieslp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（J）Promise/">（J）Promise</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-canvas的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/01/canvas的使用/" class="article-date">
  <time datetime="2018-09-01T06:11:49.000Z" itemprop="datePublished">2018-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/01/canvas的使用/">canvas的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、canvas的作用"><a href="#一、canvas的作用" class="headerlink" title="一、canvas的作用"></a>一、canvas的作用</h2><p>canvas是一个HTML元素，可以使用脚本（如JS）绘制图形，制作照片，动画，甚至实时视频处理渲染。</p>
<h2 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h2><p>canvas和img元素很像，但是没有src和alt属性，只有width和height两个属性（默认300px，150px）</p>
<h2 id="三、替代内容"><a href="#三、替代内容" class="headerlink" title="三、替代内容"></a>三、替代内容</h2><p>跟audio/vedio等标签很像，直接将替代内容写在标签里面。比较老的不支持canvas的浏览器会展示替代内容，支持的会忽略替代内容。</p>
<pre><code>&lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;  
    //这里写替代内容，文字或图片等等。
&lt;/canvas&gt;
</code></pre><h2 id="四、标签不可省"><a href="#四、标签不可省" class="headerlink" title="四、标签不可省"></a>四、标签不可省</h2><p>不同于img标签，canvas需要闭合。</p>
<p><code>&lt;/canvas&gt;结束标签</code>没有时，后面的内容都将作为替代内容。</p>
<h2 id="五、JS使用"><a href="#五、JS使用" class="headerlink" title="五、JS使用"></a>五、JS使用</h2><p>canvas创造了一块空白大小的空白画布（渲染上下文（名词）），它有一个 getContext()方法，可以获取到渲染上下文和绘画功能，它有一个参数，比如2D图形：</p>
<pre><code>var canvas = document.getElementById(&apos;canvas&apos;)
var ctx = canvas.getContext(&apos;2d&apos;)
//or
var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;)
</code></pre><p>也可以检查浏览器是否支持canvas，代码改为</p>
<pre><code>if (canvas.getContext){
      var ctx = canvas.getContext(&apos;2d&apos;);
}else{}
</code></pre><h2 id="六、绘制图形"><a href="#六、绘制图形" class="headerlink" title="六、绘制图形"></a>六、绘制图形</h2><p>首先要了解：如[100px*100px]的canvas画布的坐标空间，在左上角坐标为(0,0)，向右延申为x轴，向下为y轴，右下角坐标为(100,100)。</p>
<h3 id="1、三个画矩形的方法"><a href="#1、三个画矩形的方法" class="headerlink" title="1、三个画矩形的方法"></a>1、三个画矩形的方法</h3><ol>
<li>fillRect(x,y,width,height): 实心矩形。</li>
<li>strokeRect(x,y,width,height)：空心矩形，即矩形边框。</li>
<li>clearRect(x,y,width,height)：清除该矩形区域。</li>
</ol>
<h3 id="2、路径-画线"><a href="#2、路径-画线" class="headerlink" title="2、路径/画线"></a>2、路径/画线</h3><ol>
<li>beginPath()：新建一条路径</li>
<li>closePath()：关闭一条路径（非必需），（将笔触从当前移动到起始位置，可能会画一条直线）</li>
<li>fill()：填充路径内容（会自动关闭路径）</li>
<li>stroke()：路径描边</li>
<li>moveTo(x,y)：移动笔触</li>
<li>lineTo(x,y)：从当前位置画线到(x,y)</li>
</ol>
<p>code:</p>
<pre><code>//画一个三角形
ctx.beginPath()
ctx.moveTo(100,100)
ctx.lineTo(150,50)
ctx.lineTo(150,150)
ctx.fill()    //不写fill或stroke不会显示东西

//不管画什么都要写ctx.fill()/stroke()
//不管画什么都要写ctx.fill()/stroke()
//不管画什么都要写ctx.fill()/stroke()
</code></pre><h3 id="3、圆-圆弧"><a href="#3、圆-圆弧" class="headerlink" title="3、圆/圆弧"></a>3、圆/圆弧</h3><ul>
<li>arcTo(x1, y1, x2, y2, radius)：不可靠不作介绍</li>
</ul>
<ul>
<li><p>arc(x, y, radius, 起始弧度, 结束弧度, 方向)：</p>
<ol>
<li>弧度的计算：180°为Π（Math.PI），公式：角度/180*Math.PI = 弧度。</li>
<li>弧度为零：圆心的水平向右方向。</li>
<li>方向：true逆时针，false/不写 顺时针</li>
</ol>
</li>
</ul>
<p>举例</p>
<pre><code>//画圆
ctx.arc(100,100,50,0,Math.PI*2)
//圆弧
ctx.arc(100,100,50,0.3,6,true)
//填充圆（弧）
ctx.fill()
//描边
ctx.stroke()
</code></pre><h3 id="3、二次-三次-贝塞尔曲线"><a href="#3、二次-三次-贝塞尔曲线" class="headerlink" title="3、二次/三次 贝塞尔曲线"></a>3、二次/三次 贝塞尔曲线</h3><ol>
<li>quadraticCurveTo(x0,y0,x1,y1): 二次，起点（控制点）（x0,y0），终点（x1,y1）</li>
<li>dezierCurveTo(x0,y0,x1,y1,x2,y2)：三次，控制点1/2：(x0,y0)/(x1,y1)，结束点：(x2,y2)</li>
</ol>
<p>虽然不熟悉贝塞尔曲线，但通过多次绘制它可以用来绘制有用的图形：</p>
<pre><code>//二次
 ctx.beginPath();
 ctx.moveTo(75,25);
 ctx.quadraticCurveTo(25,25,25,62.5);
 ctx.quadraticCurveTo(25,100,50,100);
 ctx.quadraticCurveTo(50,120,30,125);
 ctx.quadraticCurveTo(60,120,65,100);
 ctx.quadraticCurveTo(125,100,125,62.5);
 ctx.quadraticCurveTo(125,25,75,25);
 ctx.stroke();
</code></pre><p>结果图：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-26/124307.jpg" alt="对话框"></p>
<p>还可以用三次贝塞尔曲线画心型等等。</p>
<h3 id="4、Path2D"><a href="#4、Path2D" class="headerlink" title="4、Path2D"></a>4、Path2D</h3><p>可以把创建的图形存为path2D对象，再引用它们。</p>
<p>code:</p>
<pre><code>ctx.strokeStyle = &quot;red&quot;
ctx.fillStyle = &quot;#00eeee&quot;
//存对象
var rectangle = new Path2D()
rectangle.rect(10, 10, 50, 50)

var circle = new Path2D();
circle.arc(100, 35, 25, 0, 2 * Math.PI)
//用对象
ctx.stroke(rectangle);
ctx.fill(circle);    
</code></pre><p>结果：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-26/97079506.jpg" alt="path2d"></p>
<h3 id="5、使用SVG-paths"><a href="#5、使用SVG-paths" class="headerlink" title="5、使用SVG paths"></a>5、使用SVG paths</h3><p>获取路径时以svg或canvavs方式重用：</p>
<pre><code>var p = new Path2D(&quot;M 80 20 h 20 v 80 h -80 Z&quot;);
ctx.fill(p)
//M 80 20 这条路径先移动到点（80，20），
//h 20 向右移20
//v 80 向下移80
//h -80 向左移80
//z  回到起点
</code></pre><p>结果图：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-26/13245959.jpg" alt="svg"></p>
<h2 id="七、指定颜色"><a href="#七、指定颜色" class="headerlink" title="七、指定颜色"></a>七、指定颜色</h2><p>如：</p>
<pre><code>ctx.fillStyle = &quot;red&quot;    //指定填充颜色为红色
ctx.strokeStyle = &quot;green&quot;   //指定描边为绿色
</code></pre><h2 id="八、指定透明度"><a href="#八、指定透明度" class="headerlink" title="八、指定透明度"></a>八、指定透明度</h2><p>如：</p>
<pre><code>ctx.fillStyle = &quot;rgba(0,0,0,0.5)&quot;
</code></pre><h3 id="所有图形的透明度"><a href="#所有图形的透明度" class="headerlink" title="所有图形的透明度"></a>所有图形的透明度</h3><pre><code>ctx.globalAlpha =  0.2
//透明度取值为0.0(完全透明)-1.0(完全不透明)
</code></pre><h2 id="九、线条样式"><a href="#九、线条样式" class="headerlink" title="九、线条样式"></a>九、线条样式</h2><ol>
<li>lineWidth=：线条宽度</li>
<li>lineCap=：线条末端<ul>
<li>（butt 默认，不加）</li>
<li>（round 加半圆半径为线条宽度一半）</li>
<li>（square 加方形）</li>
</ul>
</li>
<li>lineJoin=：线条连接处<ul>
<li>（miter 默认，尖角）</li>
<li>（bevel 平）</li>
<li>（round 圆弧）</li>
</ul>
</li>
<li>miterLimit=：连接处最大长度（内角顶点~外角顶点）</li>
<li>setLineDash()：虚线样式，接受一个数组，指定线段与间隙交替</li>
<li>getLineDash()：返回含虚线样式的数组</li>
<li>lineDashOffsest=：设置虚线偏移量。通过循环改变偏移量，有虚线在动的效果，通过延时函数控制速度。</li>
</ol>
<p>虚线例子：</p>
<pre><code>ctx.setLineDash([4, 2])
ctx.lineDashOffset = 10
ctx.strokeRect(100,20, 100, 100)
</code></pre><p>结果：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-26/25096540.jpg" alt="虚线"></p>
<h2 id="九、渐变Gradient"><a href="#九、渐变Gradient" class="headerlink" title="九、渐变Gradient"></a>九、渐变Gradient</h2><ol>
<li><p>创建Gradient对象（并定义渐变位置）</p>
<ul>
<li>createLInearGradient(x1,y1,x2,y2)：线性的渐变，参数为起点和终点。</li>
<li>createRadiusGradient(x1,y1,r1,x2,y2,r2)：圆形，参数为两个圆圆心和半径。</li>
</ul>
</li>
<li><p>渐变颜色</p>
<ul>
<li>gradient.addColorStop(position,color)：参数为欸位置（0.0~1.0）和颜色。</li>
</ul>
</li>
<li><p>把gradient对象赋给fillStyle/strokeStyle</p>
</li>
</ol>
<p>举例：</p>
<pre><code>//1.创建对象，定义位置
var gradient = ctx.createLinearGradient(0,0,0,150)
//2、定义颜色
//0-0.5：蓝-绿
//0.5-1：红-白-黑
gradient.addColorStop(0, &apos;#0000ff&apos;)
gradient.addColorStop(0.5, &apos;#00ff00&apos;)
  gradient.addColorStop(0.5, &apos;#ff0000&apos;)
gradient.addColorStop(0.75, &apos;#fff&apos;)
  gradient.addColorStop(1, &apos;#000&apos;)

  // 3、将 渐变对象 赋给fillStyle
  ctx.fillStyle = gradient
ctx.strokeStyle = gradient

  // 4、画图
  ctx.fillRect(10,10,100,130)
ctx.strokeRect(130,10,100,130);
</code></pre><p>结果图：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-26/43135778.jpg" alt="渐变"></p>
<h2 id="十、添加图案-Pattern"><a href="#十、添加图案-Pattern" class="headerlink" title="十、添加图案 Pattern"></a>十、添加图案 Pattern</h2><p>将image对象赋给图案，将图案作为填充样式：代码</p>
<pre><code>//1、创建image对象
var img = new Image();
  img.src = &apos;图片路径&apos;;
  img.onload = function(){
    // 2、用image，创建图案
    var ptrn = ctx.createPattern(img,&apos;repeat&apos;);
    // 3、用图案作填充样式
    ctx.fillStyle = ptrn;
    ctx.fillRect(0,0,350,350);
  }
</code></pre><p>结果：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-26/83555573.jpg" alt="图案"></p>
<h2 id="十一、阴影shadows"><a href="#十一、阴影shadows" class="headerlink" title="十一、阴影shadows"></a>十一、阴影shadows</h2><ol>
<li>shadowOffsetX = float<br>shadowOffsetX 和 shadowOffsetY ：向右延申距离</li>
<li>shadowOffsetY = float：向下延申距离<br>3、shadowBlur = float：阴影模糊程度<br>4、shadowColor = color：阴影颜色</li>
</ol>
<h2 id="十二、绘制文本"><a href="#十二、绘制文本" class="headerlink" title="十二、绘制文本"></a>十二、绘制文本</h2><ol>
<li>ctx.fillText(‘kakami’,10,10)：填充文字和位置</li>
<li>ctx.strkeText(‘kakami’,10,10)：只描边的文字</li>
<li>ctx.font = “48px serif”：设置font</li>
<li>ctx.textAlign=start(默认)/end/left/right/center：文字对齐方式</li>
<li>textBaseline = top/hanging/middle/bottom/alphabetic(默认)/ideographic：基线对齐方式</li>
<li>direction = ltr/rtl/inherit(默认)</li>
</ol>
<h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><ol>
<li>画完一个（描边）图形之后，没有再次写ctx.beginPath()就画一个填充图形，那第一个图形也会被填充。</li>
<li>一定要写fill/stroke()</li>
<li>使用封装函数对于减少代码量以及复杂度十分有用，如roundedRect()</li>
<li>roundedRect(ctx,10,10,5,5,3)能画圆角矩形。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Drawing_text" target="_blank" rel="noopener">MDN有关canvas</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/01/canvas的使用/" data-id="cjni9g7to000yu87lyew4s8cz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（H）canvas的使用/">（H）canvas的使用</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LocalStorage与SessionStorage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/30/LocalStorage与SessionStorage/" class="article-date">
  <time datetime="2018-08-30T03:18:00.000Z" itemprop="datePublished">2018-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/30/LocalStorage与SessionStorage/">LocalStorage与SessionStorage</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="在学习LocalStorage前先来看一下，JS中变量有什么问题："><a href="#在学习LocalStorage前先来看一下，JS中变量有什么问题：" class="headerlink" title="在学习LocalStorage前先来看一下，JS中变量有什么问题："></a>在学习LocalStorage前先来看一下，JS中变量有什么问题：</h3><pre><code>&lt;script&gt;
    var age = 18
    console.log(&apos;age = &apos; + age)
    //结果输出 age = 18
&lt;/script&gt;
</code></pre><p>在页面中改变变量 age 的值：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-11/55819352.jpg" alt="age"></p>
<p>现在的 age = 19</p>
<p>但是，刷新页面之后呢？</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-11/16450453.jpg" alt="age"></p>
<p>可以看到刷新之后页面中的age值已经又变回了 18，这就是问题所在。</p>
<h3 id="有什么办法可以使一个变量一直存在页面中或者从一个页面跳到另一个页面时值不变呢？答案就是-将变量保存在-LocalStorage里。"><a href="#有什么办法可以使一个变量一直存在页面中或者从一个页面跳到另一个页面时值不变呢？答案就是-将变量保存在-LocalStorage里。" class="headerlink" title="有什么办法可以使一个变量一直存在页面中或者从一个页面跳到另一个页面时值不变呢？答案就是 将变量保存在 LocalStorage里。"></a>有什么办法可以使一个变量一直存在页面中或者从一个页面跳到另一个页面时值不变呢？答案就是 将变量保存在 LocalStorage里。</h3><p>LocalStorage是不存储在页面中的，它存储在C盘（windows）的一个文件中。 </p>
<p>使用localStorage存变量：</p>
<pre><code>&lt;script&gt;
    let age = localStorage.getItem(&apos;age&apos;) //读取名为age的变量值
    if(! age) {
        age = 18
    }else {
        age = (+age) + 1 //（+age）将age变成数字，同 parseInt(age, 10)
    }
    console.log(&apos;age = &apos; + age)
    localStorage.setItem(&apos;age&apos;, age) //将age存进localStorage
&lt;/script&gt;
</code></pre><p>这样每次刷新都会将age加1，不会覆盖之前作的改变。</p>
<p>打开控制台-&gt;Application-&gt;Local Storage，可以看到：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-11/66361257.jpg" alt="图0"></p>
<p>可以看到当前的age值为 28，为什么没有存变量名字呢？经过一番探索，我发现可以拉动下面的框，好了，key-value现出了它的庐山真面目：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-11/13943624.jpg" alt="图1"></p>
<p>控制台打印：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-11/17297111.jpg" alt="图2"></p>
<h3 id="localStorage典型应用：记录是否提示过用户"><a href="#localStorage典型应用：记录是否提示过用户" class="headerlink" title="localStorage典型应用：记录是否提示过用户"></a>localStorage典型应用：记录是否提示过用户</h3><p>代码如下：</p>
<pre><code>let prompted = localStorage.getItem(&apos;是否提示&apos;)
if(!prompted){
    alert(&apos;这里是提示内容...&apos;)
    localStorage.setItem(&apos;是否提示&apos;,true)
}
</code></pre><p>只有第一次进去页面会有此提示：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-11/33075996.jpg" alt="图5"></p>
<p>点击确定会看到localStorage增加了一项 <code>是否提示：true</code> ：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-9-11/5605524.jpg" alt="图6"></p>
<h3 id="localStorage接口"><a href="#localStorage接口" class="headerlink" title="localStorage接口"></a>localStorage接口</h3><p>1、增加一个数据项: </p>
<pre><code>localStorage.setItem(&apos;name&apos;, &apos;xiaoxiao&apos;)
</code></pre><p>2、读取一个localStorage项：</p>
<pre><code>localStorage.getItem(&apos;name&apos;)    //xiaoxiao
localStorage.name    //xiaoxiao
</code></pre><p>3、读取所有localStorage项：</p>
<pre><code>localStorage.valueOf()    //Storage {age: &quot;33&quot;, name: &quot;xiaoxiao&quot;, length: 2}
</code></pre><p>4、读取第i项变量名：</p>
<pre><code>localStorage.key(i)    //length不算在里面
</code></pre><p>5、读取localStorage项数：</p>
<pre><code>localStorage.length    //2，只有age和name
</code></pre><p>6、移除一个localStorage项：</p>
<pre><code>localStorage.remove(&apos;name&apos;)
</code></pre><p>7、移除所有localStorage项：</p>
<pre><code>localStorage.clear()
</code></pre><p>8、检查localStorage里是否保存某个变量：</p>
<pre><code>localStorage.hasOwnProperty(&apos;name&apos;) //true
</code></pre><p>9、将数组转为字符串：</p>
<pre><code>localStorage.array = [1,2,3,4]  //[]
localStorage.array.toLocaleString()   //&quot;1,2,3,4&quot;
</code></pre><p>10、存储JSON对象为字符串：</p>
<pre><code>let sisters = {
    xiaoxiao: {
        name: &quot;xiaoxiao&quot;,
        age: 10
    },
    xiaolu: {
        name: &quot;xiaolu&quot;,
        age: 8
    }
}
localStorage.sisters = window.JSON.stringify(sisters)
//    &quot;{&quot;xiaoxiao&quot;:{&quot;name&quot;:&quot;xiaoxiao&quot;,&quot;age&quot;:10},&quot;xiaolu&quot;:{&quot;name&quot;:&quot;xiaolu&quot;,&quot;age&quot;:8}}&quot;

window.JSON.parse(localStorage.sisters) //可将字符串还原为对象
</code></pre><h3 id="SessionStorage与localStorage比较"><a href="#SessionStorage与localStorage比较" class="headerlink" title="SessionStorage与localStorage比较"></a>SessionStorage与localStorage比较</h3><p>SessionStorage作用与用法LocalStorage基本相同，不同的是，localStorage是永久有效的，除非用户清理缓存，但是sessionStorage会在页面会话后就清除。</p>
<p><strong>页面会话</strong>：在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</p>
<p>要注意的是：localStorage和sessionStorage都是仅限于页面的协议，虽然没有同源策略那么严格，但也只有相同域名的页面才能互相读取。</p>
<h4 id="sessionStorage用法与localStorage差不多，简单介绍："><a href="#sessionStorage用法与localStorage差不多，简单介绍：" class="headerlink" title="sessionStorage用法与localStorage差不多，简单介绍："></a>sessionStorage用法与localStorage差不多，简单介绍：</h4><pre><code>// 保存数据到sessionStorage
sessionStorage.setItem(&apos;key&apos;, &apos;value&apos;);

// 从sessionStorage获取数据
var data = sessionStorage.getItem(&apos;key&apos;);

// 从sessionStorage删除保存的数据
sessionStorage.removeItem(&apos;key&apos;);

// 从sessionStorage删除所有保存的数据
sessionStorage.clear();
</code></pre><h3 id="localStorage与cookie比较"><a href="#localStorage与cookie比较" class="headerlink" title="localStorage与cookie比较"></a>localStorage与cookie比较</h3><p>事实上，localStorage是一个新的对象，为了使前端能够存储数据创建，以前都是由cookie完成，但是cookie要上传到服务器，使得页面加载非常地慢速，所以现在不推荐使用cookie，他们两者主要区别是：</p>
<ul>
<li>cookie需发送到服务器，localStorage与HTTP请求无关。</li>
<li>cookie最大存储量在4kb左右，localStorage在5Mb左右（不同的浏览器各不相同）。</li>
<li>cookie默认在页面关闭后清除（后端可以设置清除时间），LocalStorage理论上永久有效，除非用户清理缓存。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/30/LocalStorage与SessionStorage/" data-id="cjni9g7tg000xu87leu8mhtiy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/（W）Web-Storage/">（W）Web Storage</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/（C）css布局/">（C）css布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（C）flex布局/">（C）flex布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（C）position/">（C）position</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（C）垂直居中/">（C）垂直居中</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（G）git入门/">（G）git入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（H）canvas的使用/">（H）canvas的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（H）html-常用标签/">（H）html-常用标签</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（H）html5-标签/">（H）html5-标签</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（JH）JS-this指向/">（JH）JS-this指向</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（JH）JS-普通函数及调用/">（JH）JS-普通函数及调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（JH）JS-构造函数、new做了什么/">（JH）JS-构造函数、new做了什么</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）JS-数据类型/">（J）JS-数据类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）JS-数据结构/">（J）JS-数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）Promise/">（J）Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）原型与原型链/">（J）原型与原型链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）继承/">（J）继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（J）自己实现-jQuery-API/">（J）自己实现-jQuery API</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（M）命令行基本命令/">（M）命令行基本命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（S）快速排序-js/">（S）快速排序-js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（S）排序算法-js/">（S）排序算法-js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）HTTP（入门）/">（W）HTTP（入门）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）Session/">（W）Session</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）Web-Storage/">（W）Web Storage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）ajax/">（W）ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）jsonp/">（W）jsonp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/（W）登录注册、cookie/">（W）登录注册、cookie</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/（C）css布局/" style="font-size: 10px;">（C）css布局</a> <a href="/tags/（C）flex布局/" style="font-size: 10px;">（C）flex布局</a> <a href="/tags/（C）position/" style="font-size: 10px;">（C）position</a> <a href="/tags/（C）垂直居中/" style="font-size: 10px;">（C）垂直居中</a> <a href="/tags/（G）git入门/" style="font-size: 10px;">（G）git入门</a> <a href="/tags/（H）canvas的使用/" style="font-size: 10px;">（H）canvas的使用</a> <a href="/tags/（H）html-常用标签/" style="font-size: 10px;">（H）html-常用标签</a> <a href="/tags/（H）html5-标签/" style="font-size: 10px;">（H）html5-标签</a> <a href="/tags/（JH）JS-this指向/" style="font-size: 10px;">（JH）JS-this指向</a> <a href="/tags/（JH）JS-普通函数及调用/" style="font-size: 10px;">（JH）JS-普通函数及调用</a> <a href="/tags/（JH）JS-构造函数、new做了什么/" style="font-size: 10px;">（JH）JS-构造函数、new做了什么</a> <a href="/tags/（J）JS-数据类型/" style="font-size: 10px;">（J）JS-数据类型</a> <a href="/tags/（J）JS-数据结构/" style="font-size: 10px;">（J）JS-数据结构</a> <a href="/tags/（J）Promise/" style="font-size: 10px;">（J）Promise</a> <a href="/tags/（J）原型与原型链/" style="font-size: 10px;">（J）原型与原型链</a> <a href="/tags/（J）继承/" style="font-size: 10px;">（J）继承</a> <a href="/tags/（J）自己实现-jQuery-API/" style="font-size: 10px;">（J）自己实现-jQuery API</a> <a href="/tags/（M）命令行基本命令/" style="font-size: 10px;">（M）命令行基本命令</a> <a href="/tags/（S）快速排序-js/" style="font-size: 10px;">（S）快速排序-js</a> <a href="/tags/（S）排序算法-js/" style="font-size: 10px;">（S）排序算法-js</a> <a href="/tags/（W）HTTP（入门）/" style="font-size: 10px;">（W）HTTP（入门）</a> <a href="/tags/（W）Session/" style="font-size: 10px;">（W）Session</a> <a href="/tags/（W）Web-Storage/" style="font-size: 10px;">（W）Web Storage</a> <a href="/tags/（W）ajax/" style="font-size: 10px;">（W）ajax</a> <a href="/tags/（W）jsonp/" style="font-size: 10px;">（W）jsonp</a> <a href="/tags/（W）登录注册、cookie/" style="font-size: 10px;">（W）登录注册、cookie</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/05/JS实现继承的几种方法/">JS实现继承的几种方法</a>
          </li>
        
          <li>
            <a href="/2018/09/28/JS构造函数（含new做了什么）/">JS构造函数（含new做了什么）</a>
          </li>
        
          <li>
            <a href="/2018/09/28/JS普通函数及调用/">JS普通函数及调用</a>
          </li>
        
          <li>
            <a href="/2018/09/28/JS中的this指向/">JS中的this指向</a>
          </li>
        
          <li>
            <a href="/2018/09/24/总结垂直居中/">垂直居中总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 lxiaox<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>