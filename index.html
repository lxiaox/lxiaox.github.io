<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>lxiaox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="lxiaox">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lxiaox">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lxiaox">
  
    <link rel="alternate" href="/atom.xml" title="lxiaox" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lxiaox</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-登录注册与cookie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/26/登录注册与cookie/" class="article-date">
  <time datetime="2018-08-26T07:33:42.000Z" itemprop="datePublished">2018-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/26/登录注册与cookie/">登录注册与Cookie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="注册与登录基本过程"><a href="#注册与登录基本过程" class="headerlink" title="注册与登录基本过程"></a>注册与登录基本过程</h2><p>登录与注册是我们日常浏览网页一个很普遍的行为，大部分网站都有用户登录机制。例如：当我们访问某一个网站时，如淘宝，不登录的时候也能看到淘宝的各种页面或者商品，但是收藏商品或将其添加至购物车时，就需要用户登录了，用户登录后就可以进行更多的操作。在用户眼中的登录注册就是用户名与密码输入正确，那么在程序中登录与注册过程中到底发生了什么？现在来总结一下：</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>首先，点击到注册页面，最简单的注册页面就是输入id（用户名或邮箱等）、输入密码、确认密码和注册按钮，通常前端程序员会在点击注册时进行一些验证，如邮箱用户名是否符合规范，两次密码是否匹配等，并作出一些修改提示，然后正确之后将这些信息发送给后端，这时后端程序员需要再进行验证，因为发送请求完全可以绕过页面的JS，比如使用curl发送请求，所以前端的验证是可有可无的，但后端的验证是必须的。当后端验证成功之后，就会将信息存入数据库。这时用户就可以进入登录页面进行验证。</p>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>登录页面与注册页面代码大同小异，当用户点击登录按钮时，浏览器就会将登录信息发送给服务器，也就是后端，后端服务器再将id与数据库中的数据进行比较，当找到匹配的id再进行密码验证，当这些都正确时，浏览器就会根据用户id获取到存储的用户信息，将相应信息填到页面中，然后将新的登录后的页面返回给客户端，也就是浏览器，展示出来。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>上面说到了服务器对用户登录的处理，事实上，在登录成功之后服务器还会做一件事情，那就是向浏览器发送一段cookie 信息，并保存在浏览器的response Header中，并且下次用户使用同一个浏览器访问这个页面时，浏览器向服务器发送请求时也会带上这段cookie数据。那么，cookie 到底是什么呢？</p>
<p>Cookie 就是一个小型的文本文件，它存储了用户的身份信息。</p>
<h4 id="cookie分类"><a href="#cookie分类" class="headerlink" title="cookie分类"></a>cookie分类</h4><p>cookie也是有时间限制的，一般默认20分钟左右，不同的浏览器不尽相同，当然也可以强制设置cookie的保存时间，没有设置期限的Cookie保存于浏览器<strong>内存</strong>，设置了过期时间就保存在<strong>硬盘</strong>中，所以按存储位置可分为<strong>内存Cookie</strong> 和 <strong>硬盘Cookie</strong>。内存cookie在浏览器关闭之后就会消失，硬盘cookie 则不会，除非用户手动删除，或到了过期时间，因此按保存时间又可以分为<strong>非持久Cookie</strong> 和 <strong>持久Cookie</strong>。</p>
<h3 id="为什么需要cookie"><a href="#为什么需要cookie" class="headerlink" title="为什么需要cookie"></a>为什么需要cookie</h3><ul>
<li>cookie的第一个作用就是<strong>记录历史</strong>。因为HTTP的无状态性，服务器不知道用户上一次作了什么，比如用户浏览器几个页面，买了几件物品，结账的时候却不知道买的物品是什么，cookie就可以记录商品信息。大致过程是：当用户选购了一样东西，服务器向用户发送页面的同时还会发送cookie记录着商品信息，当用户浏览新的页面时，又向服务器发送cookie，这样服务器就知道了购物信息，当用户想再添加商品时，只需追加cookie信息，最后结账时，服务器只需读取发来的cookie信息。</li>
<li>cookie第二个作用就是<strong>识别用户身份</strong>。当用户登录页面时，服务器会给每个用户分配id，并向页面发送送包含id的cookie，不同的用户登录时会带着不同的cookie，这样服务器就可以区分不同的用户了。</li>
<li>cookie还有一个典型应用就是自动登录，当用户登录时选中自动登录，那么下一次登录时就不需要再次输入用户名密码，这是因为服务器在用户登录之后会向用户发送cookie，cookie包含了登录凭证(用户名密码的加密形式)。只要cookie没到过期时间，下次登录浏览器就会向服务器发送cookie，cookie相当于一张门票，让用户不需再次输入用户名密码而 自动登录。</li>
</ul>
<h3 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h3><p>服务器端通过下列代码可以设置cookie：</p>
<pre><code>setcookie($name, $value, $expire, $path, $domain, $secure)
//eg：response.setHeader(&apos;Set-Cookie&apos;, `sign_in_email=${email}`) 
</code></pre><p>这里要注意 <code>$domain</code> 指定了域名，cookie是不能跨域访问的。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie" target="_blank" rel="noopener">更多设置cookie的语法</a></p>
<h3 id="cookie的缺陷"><a href="#cookie的缺陷" class="headerlink" title="cookie的缺陷"></a>cookie的缺陷</h3><ol>
<li>Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。</li>
<li>由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。</li>
<li>Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/26/登录注册与cookie/" data-id="cjlrxaee60010vw7lw811x8wv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/登录注册与cookie/">登录注册与cookie</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/25/JS数据结构/" class="article-date">
  <time datetime="2018-08-25T03:11:17.000Z" itemprop="datePublished">2018-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/25/JS数据结构/">JS中的数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天简要总结一下 JS 中的几种数据结构。</p>
<h2 id="1、哈希"><a href="#1、哈希" class="headerlink" title="1、哈希"></a>1、哈希</h2><blockquote>
<p>哈希表(Hash table，也叫散列表)，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
</blockquote>
<p>简单地说，形如键值一一对应的数据结构就是哈希。用哈希可以表示JS中的对象，根据是key-value对应，key表示对象属性，value表示属性值。如：</p>
<pre><code>var student = {
    &apos;name&apos;: &apos;Mary&apos;,
    &apos;sex&apos;: &apos;female&apos;,
    &apos;age&apos;: &apos;18&apos;,
  //&apos;key&apos;: &apos;value&apos;
}
</code></pre><p>其实<strong>数组</strong>就是一个特殊的哈希，它的 key 为排列好的数字,并且有一个key 是 length，表示数组长度。</p>
<pre><code>var array = [0,1,2,3]
//可以看作
var array = {
    &apos;0&apos;: 0,
    &apos;1&apos;: 1,
    &apos;2&apos;: 2,
    &apos;3&apos;: 3,
    &apos;length&apos;: 4
}
</code></pre><p>数组的优点是容易查找修改，缺点是难以在元素中间增加删除，因为每在中间增加或删除几个元素都意味着它之后的所有元素就要进行大挪移，都前进或都后退几位。</p>
<h2 id="2、栈"><a href="#2、栈" class="headerlink" title="2、栈"></a>2、栈</h2><p>栈是一种遵从<strong>后进先出</strong>（Last In First Out）的有序列表。栈顶元素永远是最新元素，每次只能从栈顶开始取出。可以想象成放在一只小箱子里的书本，每次往里放都放在最上面，也只能从最上面开始拿。栈的特点就是 先进后出，后进先出。</p>
<p>栈需要有如下的方法:</p>
<ul>
<li>push(element(s)): 添加几个元素到栈顶</li>
<li>pop(): 移除并返回栈顶元素</li>
<li>peek(): 返回栈顶元素</li>
<li>isAmpty: 检查栈是否为空，为空则返回true</li>
<li>clear: 移除栈中所有元素</li>
<li>size: 返回栈中元素个数。</li>
<li>print: 以字符串显示栈中所有内容</li>
</ul>
<h2 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h2><p>对列与栈很像，不过特点是 <strong>先进先出</strong>，这就跟我们人的排队是一样的。每次添加只能加在最后面，移除只能移除最前面的数据。</p>
<p>队列需要的方法：</p>
<ul>
<li>enqueue(element(s)): 向队列尾部添加几个项</li>
<li>dequeue(): 移除队列的第一项</li>
<li>front(): 返回队列的第一个元素</li>
<li>其他方法同栈一样。</li>
</ul>
<h2 id="4、链表"><a href="#4、链表" class="headerlink" title="4、链表"></a>4、链表</h2><blockquote>
<p>链表是一组节点组成的集合，每个节点都使用一个对象的引用来指向它的后一个节点。指向另一节点的引用讲做链。</p>
</blockquote>
<ol>
<li>单向链表中每个节点都具有两个部分，一个储存自身信息，一个指向下一个节点。</li>
<li>双向链表中每个节点则具有三个部分，一个储存自身信息，一个指向上一个节点，一个指向下一个节点。</li>
</ol>
<p>因此链表区别于数组的是容易增加删除，只需要改变指针指向即可，但是它想要找到一个节点却很困难，只能从第一个节点开始不停地找下一个节点直到找到。</p>
<p><em>队列、栈可以用数组实现，而链表可以用哈希（即JS 对象）实现。</em></p>
<p>这里说一下，哈希正是一种结合了数组和链表的优点的数据结构，既容易寻址查找，又容易插入删除。</p>
<h2 id="5、树"><a href="#5、树" class="headerlink" title="5、树"></a>5、树</h2><p>之前的栈、队列、链表等都是顺序数据结构，而树就是一种<strong>非顺序结构</strong>。树形状像一颗根在上的倒挂的树，以此命名，如下图：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/tree1.png" alt="树"></p>
<h4 id="树的基本概念："><a href="#树的基本概念：" class="headerlink" title="树的基本概念："></a>树的基本概念：</h4><ul>
<li>节点：树中的每个元素都叫节点；</li>
<li>根节点：没有父节点的节点，树只有唯一的根节点，图中为 A；</li>
<li>子节点：从节点延申而下的都叫子节点；</li>
<li>内部节点：有子节点的节点（B C D）或称中间节点；</li>
<li>叶子节点：没有子节点的节点(E F G H I J)，又称终端节点；</li>
<li>节点层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>节点深度：从根 到 该节点的路径长，根的深度为0；</li>
<li>节点高度：从该节点 到 一个叶子节点的最长路径长，叶子节点的高度为0；</li>
<li>树的深度：所有节点深度的最大值；</li>
<li>树的高度：所有节点高度的最大值；</li>
<li>节点的度：一个节点含有的子树的个数称为该节点的度；</li>
<li>树 的 度：一棵树中，最大的节点的度称为树的度；</li>
<li>注：关于根节点的深度高度的基数为0 或1 说法不一。</li>
</ul>
<h4 id="树的种类："><a href="#树的种类：" class="headerlink" title="树的种类："></a>树的种类：</h4><ol>
<li>无序树：树中任意节点的子节点之间没有顺序关系，也称为自由树；</li>
<li>有序树：树中任意节点的子节点之间有顺序关系；<ul>
<li>二叉树：每个节点最多含有两个子树的树称为二叉树；</li>
<li>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；</li>
<li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。</li>
</ul>
</li>
</ol>
<p>其中二叉树又分为：</p>
<ul>
<li>完全二叉树：除了最底层，所有层的节点数均达到最大值，最底层的左右节点连续紧密地排列，这样的二叉树叫做完全二叉树。</li>
<li>满二叉树：所有叶子节点均在最底层的二叉树。<em>满二叉树和完全二叉树用数组就可以表示</em>。</li>
</ul>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/%E6%BB%A1-%E5%AE%8C%E5%85%A8-%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="满/完全二叉树"></p>
<ul>
<li>平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li>
<li>排序二叉树(二叉查找树)：只允许你在左侧节点储存比父节点小的值，右侧只允许储存比父节点大的值。也称二叉搜索树、有序二叉树；</li>
</ul>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="二叉查找树"></p>
<h5 id="还有一种特殊的数据结构—-堆"><a href="#还有一种特殊的数据结构—-堆" class="headerlink" title="还有一种特殊的数据结构—-堆"></a>还有一种特殊的数据结构—-堆</h5><p><strong>堆(heap)</strong>，形状上像完全二叉树，堆的特点是所有父节点都比它的子节点要大（最大堆） 或者要小（最小堆）。正如我们堆东西将大的放下面，小的放上面，树不能表现出这种特性，所以叫做堆。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/25/JS数据结构/" data-id="cjlrxaedl000hvw7l03jt907q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS数据结构/">JS数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/23/JS排序算法/" class="article-date">
  <time datetime="2018-08-23T03:54:32.000Z" itemprop="datePublished">2018-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/23/JS排序算法/">日常学习JS排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不断更新中……</p>
<p>冒泡，选择，插入，计数，桶排序，基数排序……</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li>基本思想：重复走访要排序的数列，一次比较两个元素，如果这两个数顺序错误就将其交换，每次走访都能找到一个最值，重复走访直到没有要进行交换的元素，那么排序就完成了。</li>
<li>时间复杂度：O(n^2)</li>
<li>冒泡排序过程（升序）：<ol>
<li>比较第一对相邻的元素，如果第一个比第二个大，就交换他们两个。</li>
<li>按1的方法比较第二对相邻元素，即第二个与第三个，以此类推直到最后一对元素，这时，最后的元素就是最大的数。</li>
<li>再次重复步骤1、2比较除最后一个数的所有元素。</li>
<li>如此每次都找到一个当前最大值下次不需在参与比较，直到没有任何一对数字需要比较。</li>
</ol>
</li>
<li><p>JS 代码：</p>
<pre><code>Array.prototype.bubbleSort = function() {
    var i, j, temp;
    for (i = 0; i &lt; this.length - 1; i++)
        for (j = 0; j &lt; this.length - 1 - i; j++)
            if (this[j] &gt; this[j + 1]) {
                temp = this[j];
                this[j] = this[j + 1];
                this[j + 1] = temp;
            }
    return this;
};
var num = [2,9,5,8,10,1,32]
num.bubbleSort()
console.log(num)    // [1, 2, 5, 8, 9, 10, 32]
</code></pre></li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul>
<li>基本思想：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>
<li>时间复杂度：O(n^2)</li>
<li><p>JS 代码：</p>
<pre><code>Array.prototype.selectionSort = function() {
    var i, j, temp, min
    for (i = 0; i &lt; this.length - 1; i++) {
      min = i
        for (j = i + 1; j &lt; this.length - 1; j++) {
            if (this[j] &lt; this[min]) {
              min = j
            }
        }
      temp = this[i]
      this[i] = this[min]
      this[min] = temp
    }            
    return this
}
var num = [2,9,5,8,10,1,32]
num.selectionSort()
console.log(num)    // [1, 2, 5, 8, 9, 10, 32]
</code></pre></li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>基本思想：将第一个元素视为已排列元素，取出下一个元素从后向前地与已排列元素进行对比，如果下一个元素（即新元素）比某个元素小，就将这个元素往后移一位，一直比较直到找到小于或等于新元素的，将新元素插到这个元素之后，再重复将多有元素排完。</li>
<li>时间复杂度：O(n^2)</li>
<li><p>JS 代码：</p>
<pre><code>Array.prototype.insertionSort = function() {
  var i, j
  for(i = 1; i &lt; this.length; i++) {
    for(j = 0; j &lt; i; j++){
      if(this[j] &gt; this[i]){
        this.splice(j,0,this[i])
        this.splice(i+1,1)
        break
      }
    }
  }
}
var num = [2,9,5,8,10,1,32]
num.insertionSort()
console.log(num)    // [1, 2, 5, 8, 9, 10, 32]
</code></pre></li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>基本思想</li>
<li>时间复杂度</li>
<li>JS代码：</li>
</ul>
<h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><ul>
<li>基本思想</li>
<li>时间复杂度</li>
<li>JS代码：</li>
</ul>
<h3 id="排序-2"><a href="#排序-2" class="headerlink" title="排序"></a>排序</h3><ul>
<li>基本思想</li>
<li>时间复杂度</li>
<li>JS代码：</li>
</ul>
<p>点击<a href="https://visualgo.net/en" target="_blank" rel="noopener">查看排序动画的网站</a>，可以更直观地了解排序的具体过程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/23/JS排序算法/" data-id="cjlrxaed20009vw7laczexer4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS中的排序算法/">JS中的排序算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AJAX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/23/AJAX/" class="article-date">
  <time datetime="2018-08-23T01:59:51.000Z" itemprop="datePublished">2018-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/23/AJAX/">AJAX</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上节我们介绍了JSONP与跨域，JSONP是一种通过 script 发送请求的跨域技术，但是我们也提到了 jsonp 的缺点，那就是 jsonp 是通过 script 只能发送 GET 请求，并只能以脚本运行。那么有没有方式能实现各种请求方式<code>（get、post、put、delete...）</code>，并且我们想以什么方式展示都可以呢？针对这个需求，微软率先做出了突破。IE 5 在JS中引入了一个 ActiveX 对象，使得 JS 可以直接发起 HTTP 请求，随后 Mozilla、Safari、Opera 等浏览器也引进该对象，并取名 <code>XMLHttpRequest</code> ，被纳入 <a href="https://www.w3.org/Consortium/" target="_blank" rel="noopener">W3C</a> 规范。</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>使用上述对象  XMLHttpRequest 发送请求的步骤：</p>
<ol>
<li>使用 XMLHttpRequest 发请求，</li>
<li>服务器返回XML格式的字符串（现在大多使用<a href="https://www.json.org/" target="_blank" rel="noopener">JSON</a>格式），</li>
<li>JS 解析 XML ，并更新局部页面。<br><a href="https://zh.wikipedia.org/wiki/%E5%82%91%E8%A5%BF%C2%B7%E8%A9%B9%E5%A7%86%E5%A3%AB%C2%B7%E8%B3%88%E7%91%9E%E7%89%B9" target="_blank" rel="noopener">Jesse James Garrett</a> 将以上技术取名为 <code>AJAX</code> ，全称是 <code>Asynchronous JavaScript And XML</code>，意为异步的 JavaScript 和 <a href="https://zh.wikipedia.org/zh-hans/XML" target="_blank" rel="noopener">XML</a>。</li>
</ol>
<h2 id="用原生JS发-AJAX-请求实例"><a href="#用原生JS发-AJAX-请求实例" class="headerlink" title="用原生JS发 AJAX 请求实例"></a>用原生JS发 AJAX 请求实例</h2><p>上文提到使用 AJAX 的基本步骤，现在写一个请求实例。<br>客户端JS代码：</p>
<pre><code>//页面中有一个 myButton 按钮，点击它发送请求。
myButton.addEventListener(&apos;click&apos;,(e)=&gt;{
    //创建XMLHttpRequest对象
    let request = new XMLHttpRequest()
    //配置请求：动作，协议，域名，路径...
    request.open(&apos;get&apos;,&apos;http://baidu.com/xyz&apos;)
    //1、发送XML请求
    request.send()
    //2、服务器发送XML(JSON)字符串
    //3、JS解析XML
    request.onreadystatechange = ()=&gt;{
        if(request.readystate === 4){
            if(request.status &gt;= 200 &amp;&amp; request.status &lt;300){
                let string = request.responseText
                //把JSON格式的字符串转换为JS对应值
                let object = wndow.JSON.parse(string)
            }else if(request.status &gt;= 400){
                console.log(&apos;说明请求失败&apos;) 
             }
        }
    }
})
</code></pre><p>服务端部分代码：</p>
<pre><code>if(path===&apos;/xxx&apos;){
    response.statusCode = 200
    //设置响应第四部分数据格式为json格式
    response.setHeader(&apos;Content-Type&apos;, &apos;text/json;charset=utf-8&apos;)
    //下行代码在后文说明
    response.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://abcdef.com:8001&apos;)
    response.write(`
    {
      &quot;note&quot;:{
        &quot;to&quot;: &quot;B同学&quot;,
        &quot;from&quot;: &quot;A同学&quot;,
        &quot;heading&quot;: &quot;打招呼&quot;,
        &quot;content&quot;: &quot;hi&quot;
      }
    }
    `)
    response.end()
</code></pre><p>上述代码即使用AJAX发送请求，及服务器返回数据的过程。其中值得注意的是 <code>response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;http://abcdef.com:8001&#39;)</code> ，这一行代码就是为了应对浏览器的同源策略（只有协议+域名+端口完全一致才能获取到请求的数据）的机制，叫做 <code>CORS ( Cross-Origin Resource Sharing)</code>，即跨站资源共享，代码中 <code>Access-Control-Allow-Origin</code> 告诉浏览器，允许后面的网页跨域访问。</p>
<h2 id="封装一个-ajax"><a href="#封装一个-ajax" class="headerlink" title="封装一个 ajax()"></a>封装一个 ajax()</h2><p>为了方便使用AJAX发送请求，我们可以将上面的客户端代码封装成一个函数 ajax()：</p>
<pre><code>window.jQuery.ajax = function(url,method,body,headers,success, fail){
    let request = new XMLHttpRequest()
    request.open(method,url)
    for(let key in headers) {
         let value = headers[key]
          request.setRequestHeader(key, value)
    }
    request.readystatechange = ()=&gt;{
        if(request.readystate === 4){
            if(request.status &gt;= 200 &amp;&amp; request.status &lt;300){
                success.call(&apos;undefined&apos;,request.responseText)
            }else if(request.status &gt;= 400){
                fail.call(&apos;undefined&apos;,request)
            }
        }
    }
    request.send(body)
}
</code></pre><p>这样我们使用的时候只需将请求方式，路径，请求体（请求第四部分），成功函数，失败函数传 给 ajax() 即可。</p>
<p>事实上使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">promise</a> 升级这个 ajax() 使其更加方便使用。</p>
<pre><code>//这里我们可以将参数封装成一个对象（ES6语法,解构赋值）
window.jQuery.ajax = function({url,method,body,headers}){
    return new Promise(function(resolve, reject) {
        let request = new XMLHttpRequest()
        request.open(method, url)
        for(let key in headers) {
             let value = headers[key]
              request.setRequestHeader(key, value)
        }
        request.readystatechange = () =&gt; {
            if (request.readystate === 4) {
                if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) {
                    resolve.call(&apos;undefined&apos;, request.responseText)
                } else if (request.status &gt;= 400) {
                    reject.call(&apos;undefined&apos;, request)
                }
            }
        }
        request.send(body)
    })
}

//按以下方式调用
jQuery.ajax({
    url: &apos;/xxx&apos;,
    method: &apos;get&apos;
}).then(success, fail)
</code></pre><h2 id="AJAX-的功能"><a href="#AJAX-的功能" class="headerlink" title="AJAX 的功能"></a>AJAX 的功能</h2><ul>
<li>客户端的 JS 发送请求</li>
<li>服务端的 JS 发送响应</li>
</ul>
<p>一、客户端 JS 设置请求各部分：</p>
<ol>
<li>第一部分 <code>request.open(&#39;get&#39;, &#39;/xxx&#39;)</code></li>
<li>第二部分 <code>request.setHeader(&#39;content-type&#39;,&#39;x-www-form-urlencoded&#39;)</code></li>
<li>第四部分 <code>request.send(&#39;a=1&amp;b=2&#39;)</code></li>
</ol>
<p>二、客户端 JS 获取响应各部分</p>
<ol>
<li>第一部分 <code>request.status（响应码） / request.statusText（响应码解释）</code></li>
<li>第二部分 <code>request.getResponseHeader() / request.getAllResponseHeaders()（一个或所有响应头）</code></li>
<li>第四部分 <code>request.responseText</code></li>
</ol>
<p>三、服务端 JS 获取请求各部分</p>
<ol>
<li>第一部分 <code>request.method，request.url</code></li>
<li>第二部分 <code>request.header</code></li>
<li>第四部分 <code>request.body</code></li>
</ol>
<p>四、服务端 JS 设置响应各部分：</p>
<ol>
<li>第一部分 <code>response.statusCode = 200</code></li>
<li>第二部分 <code>response.setHeader(&#39;Content-Type&#39;, &#39;text/html;charset=utf-8&#39;)</code></li>
<li>第四部分 <code>response.write(&#39;hi...&#39;)</code></li>
<li>响应结束 <code>response.end()</code></li>
</ol>
<p>另：本文中使用了</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">promise语法</a></li>
<li><a href="https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html" target="_blank" rel="noopener">回调函数</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/23/AJAX/" data-id="cjlrxaecx0006vw7luexxpbl0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/跨域之ajax/">跨域之ajax</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JSONP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/17/JSONP/" class="article-date">
  <time datetime="2018-08-17T02:22:50.000Z" itemprop="datePublished">2018-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/17/JSONP/">JSONP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JSONP（全称是 JSON with Padding）是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。JSONP通过GET请求向服务器请求数据。</p>
<h2 id="浏览器发送请求的历史"><a href="#浏览器发送请求的历史" class="headerlink" title="浏览器发送请求的历史"></a>浏览器发送请求的历史</h2><p>在了解JSONP之前，先来看看在JSONP之前浏览器是怎么向服务器发送请求的，前端程序员经过长时间的探索，曾先后使用过form、img等标签发请求，然而</p>
<ul>
<li>form（可以发送post、get等请求）表单会刷新页面，在新的页面中显示成功或失败，这个时候可以将新页面展示在iframe中，但这专门用来防止刷新的iframe无疑是碍眼的；</li>
<li>img标签（发送get请求）只知道成功、失败，无法获取更多的数据；</li>
<li>a标签（发送get请求）同样会刷新页面；</li>
<li>link（发送get请求）只能以css、favcon的形式展示；</li>
</ul>
<h2 id="SRC"><a href="#SRC" class="headerlink" title="SRC"></a>SRC</h2><p>那有什么办法能够更好的发送请求并得到数据呢？程序员发现script标签很好地实现了这种需求，并将这种解决策略称为<strong>SRC</strong>（Server Rendered JavaScript）即服务器返回JS。顾名思义，在这种方法中，浏览器向服务器请求script，服务器则进行相关操作，并返回一段JS数据告诉客户端也就是浏览器页面进行局部刷新。</p>
<p>接下来看客户端的代码：</p>
<pre><code>&lt;body&gt;
    &lt;p style=&quot;color:red;&quot;&gt;您的余额是&lt;span id=amount&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;&lt;/p&gt;
    &lt;button id=button&gt;付款&lt;/button&gt;
    &lt;script&gt;
        $(&apos;#button&apos;).on(&apos;click&apos;,function(){
           //首先新建一个scrippt标签，路径为/pay
           let script=document.createElement(&apos;script&apos;) 
           script.src=&apos;pay&apos; 
           document.body.appendChild(script)
           //加载成功后删除这个script，节省内存
           script.onload=function(e){
                e.currentTarget.remove()
            }
           //script加载失败通知用户
           script.onerror=function(e){
                alert(&apos;fail&apos;); 
                e.currentTarget.remove()
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre><p>服务端代码：</p>
<pre><code>if(path === &apos;/&apos;){
    let string=fs.readFileSync(&apos;./index.html&apos;,&apos;utf8&apos;)
    let amount=fs.readFileSync(&apos;./db&apos;,&apos;utf8&apos;)
    //这里的db为自建的文件充当数据库
    string=string.replace(&apos;&amp;&amp;&amp;amount&amp;&amp;&amp;&apos;,amount)
    response.statusCode = 200
    //写响应头
    response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;)
    //响应体，即返回给浏览器的内容
    response.write(string)
    response.end()
} else if (path === &apos;/pay&apos;){
    let amount=fs.readFileSync(&apos;./db&apos;,&apos;utf8&apos;)
    amount--    //付款1元，余额减1
    //新的余额写进数据库
    fs.writeFileSync(&apos;./db&apos;,amount)  
    response.statusCode = 200
    response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript;charset=utf-8&apos;)
    //这里是返回给客户端的JS代码
    response.write(`
      amount.innerText--
    `) 
    response.end()
}
</code></pre><p>这就是SRC的流程，然而这段代码中还存在着一个问题，不难看出，这里是由后端代码返回操作页面的JS代码，这就要求后端程序员掌握前端代码写法，并且必须对页面内容非常地熟悉，我们把这种代码杂糅称为代码的耦合，那么，为了解决这个问题，就说到了今天的重头戏–JSONP。</p>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>上面说到了解决代码耦合，方法就是将上述后端写的前端代码，先封装为一个函数写在js中，发送script请求时，同时将这个函数作为请求参数传给服务器，这样后端就不需要写这些代码，只需要调用这个函数就行了。<br>代码修改如下：</p>
<pre><code>//1、客户端加上请求参数
//注意，为了统一，请求参数的名字规定叫做callback，以便所有人使用
script.src=&apos;/pay?callback=函数名&apos;
//2、封装函数，注意这里的函数名一般都加上随机以免造成变量名冲突。
//例如: let 函数名 = &apos;xxx&apos; + parseInt(Math.random()*10000,10)
window.函数名=function(result){
        amount.innerText = result.left
}

//3、服务器，修改原来的请求头数据格式javascript为json
response.setHeader(&apos;Content-Type&apos;, &apos;application/json;charset=utf-8&apos;)
//4、修改响应第四部分，调用请求参数callback即我们传入的 函数
response.write(`
    ${query.callback}.call(undefined,{
        &quot;success&quot;:true,
        &quot;left&quot;:${amount}
    })
`)
</code></pre><p>在上面的服务器代码响应第四部分中，给函数传入了参数：</p>
<pre><code>${query.callback}.call(undefined,{
    &quot;success&quot;:true,
    &quot;left&quot;:${amount}
})
</code></pre><p>这个参数包含了执行结果（成功）以及返回的数据（新的余额），这个参数的数据格式就是JSON对象，它左右的内容 <code>${query.callback}.call(undefined,</code> 与 <code>)</code>  分别是 左padding 和 右padding，这就是 <code>Json with Padding</code> 名字的由来。</p>
<p>当然，理论上这里的参数实际上并不一定需要JSON对象，只是对象能表示更多的数据，并且JSON对象能被JS解析，如果你想学习JSON，<a href="https://www.json.org/" title="这里是JSON官网" target="_blank" rel="noopener">点击去JSON官网</a>。</p>
<h2 id="JSONP与跨域"><a href="#JSONP与跨域" class="headerlink" title="JSONP与跨域"></a>JSONP与跨域</h2><p>上述讲了浏览器是怎么通过 JSONP 发送请求得到数据的，似乎还没提到怎么实现跨域。</p>
<blockquote>
<p>先来了解一下跨域：只有 <strong>协议、域名、端口</strong> 完全一样才被浏览器认为是同一个域，在一个网站中浏览器不能跨域执行另一个网站的脚本，这就是浏览器的 <strong>同源策略</strong>，也就是说你可以跨域发送请求，但是请求到的非同源数据会被拦截。浏览器的同源策略保护了数据的安全，但同时也造成了一些问题，比如一个公司有不同的子域需要互相访问，或者调用外部API，因此有时候我们就有了跨域的需求。</p>
</blockquote>
<p>那么JSONP是怎么跨域的呢？我们已经知道了是 JSONP 通过 script 发送GET请求，事实上，<strong>script 请求是不受同源策略限制的，请求到的script资源会被立即执行</strong>，JSONP就是利用了这一特性来实现跨域。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后来总结一下 JSONP 的过程：</p>
<ol>
<li>请求方动态创建一个 script 元素，src 指向响应方，并传递一个 callback=xxx 的参数；</li>
<li>响应方作出形如 callback.call(‘undefined’,‘要的数据’) 或者 callback(‘要的数据’) 的响应；</li>
<li>请求方接到响应，调用 xxx.call(‘undefined’,‘要的数据’)；</li>
<li>这样请求方就得到了他要的数据。</li>
</ol>
<p>面试题：为什么JSONP不能发送POST请求？<br>答案：因为JONP是通过动态创建script标签实现的，script标签只能发送GET请求。</p>
<p>最后介绍一个jQuery使用JSONP的简单方法。</p>
<pre><code>$.ajax({
    url: &quot;http://xxx.com:8002/pay&quot;,
    dataType: &quot;jsonp&quot;,
    success: function( response ) {
        if(response === &apos;success&apos;){
            amount.innerText = amount.innerText - 1
        }
    }
})
</code></pre><p>虽然名字叫 <code>ajax</code>，但是两者并没有任何联系，事实上应该叫做 <code>jsonp</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/17/JSONP/" data-id="cjlrxaecz0007vw7lvkwcmto9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/跨域之jsonp/">跨域之jsonp</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-实现一个jQuery的API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/04/实现一个jQuery的API/" class="article-date">
  <time datetime="2018-07-04T14:20:26.000Z" itemprop="datePublished">2018-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/04/实现一个jQuery的API/">实现一个jQuery的API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通过自己动手写 API 来学习 jQuery！</p>
<h3 id="第1个API：addClass"><a href="#第1个API：addClass" class="headerlink" title="第1个API：addClass"></a>第1个API：addClass</h3><p>功能：通过节点或选择器给元素添加一个类</p>
<h3 id="第2个API：setText"><a href="#第2个API：setText" class="headerlink" title="第2个API：setText"></a>第2个API：setText</h3><p>功能：设置元素的文本内容</p>
<p>代码：</p>
<p> html：</p>
<pre><code>&lt;body&gt;
  &lt;div&gt;hello&lt;/div&gt;
  &lt;div&gt;hello&lt;/div&gt;
  &lt;div&gt;hello&lt;/div&gt;
  &lt;div&gt;hello&lt;/div&gt;
  &lt;div&gt;hello&lt;/div&gt;
&lt;/body&gt;
</code></pre><p> css： </p>
<pre><code>div{
  border:1px solid red;
  width: 150px;
  height: 25px;
  margin-top: 10px;
}
.blue{  color:blue; }
.high{  height:50px; }
.narrow{  width:60px; }
</code></pre><p>此时效果为：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-7-4/94812649.jpg" alt="原始结果"></p>
<p> js：</p>
<pre><code>//jQuery就是一个函数，传进一个节点或选择器nodeOrSelector，返回一个对象nodes。
window.jQuery = function(nodeOrSelector){
  let nodes = {}
  if(typeof nodeOrSelector === &apos;string&apos;){
    //如果参数为字符串类型，也就是代表一个选择器，就获取到选择的所有元素存入nodes。
    let temp = document.querySelectorAll(nodeOrSelector)
    for(let i = 0; i&lt;temp.length; i++){
       nodes[i] = temp[i]
    }
    nodes.length = temp.length
  }else if( nodeOrSelector instanceof Node){
        //如果参数是一个节点，那就只存一个节点；为了返回结果的一致性，仍将其存为伪数组。
        nodes = {
          0: nodeOrSelector,
          length: 1
        }
  }

  //API1 添加一个类
  nodes.addClass = function(class1){
      for(let i = 0; i&lt;nodes.length; i++){
        nodes[i].classList.add(class1)
      }

  }

    //添加多个类
    //     nodes.addClass = function(classes){
    //       classes.forEach( (value)=&gt;{
    //         for(let i = 0; i&lt;nodes.length; i++){
    //           nodes[i].classList.add(value)
    //         }
    //       })

    //     }

  //API2 设置文本内容
  nodes.setText = function(text){
    for(let i = 0; i&lt;nodes.length; i++){
     nodes[i].textContent = text 
    }

  }
  //nodes的key为0，1，2，...，length，addClass，setText等
  return nodes  
}

window.$ = jQuery    //$为代替jQuery的缩写符,同时，在变量前加上$，可以区分jQuery与Dom的变量
var $div = $(&apos;div&apos;)    //传入了选择器&apos;div&apos;,$div即返回的对象nodes
$div.addClass(&apos;blue&apos;)
//$div.addClass([&apos;blue&apos;,&apos;high&apos;,&apos;narrow&apos;])//添加多个类
$div.setText(&apos;hi&apos;) 
</code></pre><p>添加’blue’类的效果：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-7-4/73660343.jpg" alt="结果1"></p>
<p>添加多个类的效果：</p>
<p><img src="http://p8rplhkt6.bkt.clouddn.com/18-7-4/88773623.jpg" alt="结果2"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/04/实现一个jQuery的API/" data-id="cjlrxaedp000lvw7lfco2gmxa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery-API/">jQuery-API</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-原型与原型链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/13/原型与原型链/" class="article-date">
  <time datetime="2018-06-13T13:37:24.000Z" itemprop="datePublished">2018-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/13/原型与原型链/">原型与原型链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="构造函数与对象"><a href="#构造函数与对象" class="headerlink" title="构造函数与对象"></a>构造函数与对象</h3><p>在JS中规定全局对象window（浏览器中是window，ECMAScript中是global）具有很多属性，例如可以用来创建各种类型对象的<code>Number()</code>、<code>String()</code>、<code>Boolean()</code>、<code>Object()</code>等构造函数。</p>
<pre><code>//用构造函数创建一个实例对象
var a = new Number(123)
a  //Number {123}
</code></pre><p>复杂对象具有各种属性，基本类型数据可以引用复杂对象的各种属性是临时创建了一个复杂对象。</p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每个函数都有一个prototype属性，它指向该函数的<strong>原型</strong>，原型里具有该函数的公用属性，为节省内存空间，将这些公用属性存为一个对象，可供多个函数引用。对象的<code>__proto__</code>属性与它的构造函数的prototype指向同一个对象。</p>
<ul>
<li><code>函数Number的prototype属性指向Number.prototype对象</code>。</li>
<li><code>Number.prototype.__proto__===Object.prototype</code>.</li>
</ul>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>每个JS对象（除null）都具有的属性，它指向该对象的原型。<br><br>在例子中 <code>a 的__proto__属性也指向 Number.prototype</code>。</p>
<h3 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h3><blockquote>
<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
</blockquote>
<h3 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h3><p>原型也是对象，原型也可以引用原型，同时，我们也可以创建它。</p>
<ul>
<li>JS中原型最顶层为对象创建函数的原型<code>Object.prototype</code></li>
<li><code>Object.prototype.__proto__===null</code>。</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>由相互关联的原型组成的链状结构就是原型链。</li>
</ul>
<p><br>例如关系图中红色的这条线：<br><img src="http://p8rplhkt6.bkt.clouddn.com/18-6-13/73261713.jpg" alt="关系图"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/13/原型与原型链/" data-id="cjlrxaee80011vw7l2n0hu7ee" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原型与原型链/">原型与原型链</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS中的数据类型转换" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/12/JS中的数据类型转换/" class="article-date">
  <time datetime="2018-06-12T10:27:22.000Z" itemprop="datePublished">2018-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/12/JS中的数据类型转换/">JS中的数据类型转换</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1、转为string"><a href="#1、转为string" class="headerlink" title="1、转为string"></a>1、转为string</h2><p><strong>方法一：toString()</strong></p>
<ul>
<li>格式：<code>(123).toString()===&quot;123&quot;</code></li>
<li>适用于<code>number</code>、<code>boolean</code>。</li>
<li><code>symbol</code>不能用。</li>
<li><code>null</code>、<code>number</code>会报错，显示该类型不能使用这个函数。</li>
<li><code>object</code>的结果是<code>&quot;[object Object]&quot;</code>。同法二、法三。</li>
</ul>
<p><strong>方法二：加上空字符串</strong></p>
<ul>
<li>格式：<code>1 + &#39;&#39;===&quot;1&quot;</code> 或 <code>&#39;&#39; + 1===&quot;1&quot;</code>。</li>
<li>与方法一不同的是<code>null</code>、<code>undefined</code>类型也可使用。结果为<code>&quot;null&quot;</code>、<code>&quot;undefined&quot;</code>。</li>
<li>原因：<code>+</code> 两边数据类型不同时，会将其转换为同一类型，string优先。</li>
</ul>
<p><strong>方法三：String()全局函数</strong></p>
<ul>
<li>格式：<code>String(1)===&quot;1&quot;</code></li>
<li>使用范围同方法二。</li>
</ul>
<h2 id="2、转为number"><a href="#2、转为number" class="headerlink" title="2、转为number"></a>2、转为number</h2><p><strong>方法一：Number()函数</strong></p>
<ul>
<li>格式：<code>Number(&#39;123&#39;)===123</code>。</li>
<li>注意：数据中含非数值，结果为NaN。如：<code>Number(&#39;123s&#39;)--&gt;NaN</code>。（不是===，NaN不等于任何数，包括NaN）。</li>
</ul>
<p><strong>方法二：parseInt()函数</strong></p>
<ul>
<li>格式：<code>parseInt(&#39;11&#39;)===11</code>。</li>
<li>可以在其中写不同的进制，比如<code>parseInt(&#39;101&#39;,16)===257</code>，将‘101’作为16进制数转换，得到十进制257。</li>
<li>注意1：遇到第一个数就是非数值时，结果是<strong>NaN</strong>。如：<code>parseInt(&#39;sdf&#39;)--&gt;NaN</code>。</li>
<li>注意2：若开头为数值，后为非数值，则会转换到最后一个数值作为结果。如：<code>parseInt(&#39;123sdf&#39;)===123</code>。</li>
</ul>
<p><strong>方法三：parseFloat()函数</strong></p>
<ul>
<li>用以转换浮点小数。</li>
<li>格式：<code>parseFloat(&#39;1.23&#39;)===1.23</code>。</li>
<li>注意1：遇到第一个数就是非数值时，结果是<strong>NaN</strong>。</li>
<li>注意2：若开头为数值，后为非数值，则会转换到最后一个数值作为结果。如：<code>parseFloat(&#39;1.23sdf&#39;)===1.23</code>。</li>
</ul>
<p><strong>方法四：减去数值0</strong></p>
<ul>
<li>格式：<code>&#39;123&#39;-0===123</code>。</li>
<li>注意：数据中含非数值，结果为NaN。如：<code>&#39;1s&#39;-0---&gt;NaN</code>。</li>
</ul>
<p><strong>方法五：在原数据前加上加号</strong></p>
<ul>
<li>格式：<code>+&#39;123&#39;===123</code>。</li>
<li>注意：+’xxx’只是对其取<strong>原值</strong>，并非绝对值。如：<code>+&#39;-1&#39;===-1</code>。</li>
<li>注意：数据中含非数值，结果为NaN。如：<code>+&#39;1s&#39;---&gt;NaN</code>。</li>
</ul>
<h2 id="3、转为boolean"><a href="#3、转为boolean" class="headerlink" title="3、转为boolean"></a>3、转为boolean</h2><p><strong>方法一：Boolean()函数</strong></p>
<ul>
<li>格式：<code>Boolean(1)===true</code>。</li>
<li>falsy值定义：在Boolean 上下文中认定可转换为false的值。</li>
<li>5个falsy值：<code>0</code>、<code>NaN</code>、<code>&#39;&#39; 空string</code>、<code>null</code>、<code>undefined</code>。</li>
<li>所有object（包括空对象）都为true。</li>
</ul>
<p><strong>方法二：加“!!”</strong></p>
<ul>
<li>在数据前加<code>!!</code></li>
<li>格式：<code>!!&#39;null&#39;===true</code>、<code>!!null===false</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/12/JS中的数据类型转换/" data-id="cjlrxaedg000evw7l4fmsl7uz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS中的数据类型转换/">JS中的数据类型转换</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS中的数据类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/09/JS中的数据类型/" class="article-date">
  <time datetime="2018-06-09T15:07:26.000Z" itemprop="datePublished">2018-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/09/JS中的数据类型/">JS中的数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="js共有七种数据类型：number、string、boolean、symbol（ES6新增）、null、undefined、object"><a href="#js共有七种数据类型：number、string、boolean、symbol（ES6新增）、null、undefined、object" class="headerlink" title="js共有七种数据类型：number、string、boolean、symbol（ES6新增）、null、undefined、object"></a>js共有七种数据类型：number、string、boolean、symbol（ES6新增）、null、undefined、object</h3><blockquote>
<p>通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。</p>
</blockquote>
<h2 id="数值（number）："><a href="#数值（number）：" class="headerlink" title="数值（number）："></a>数值（number）：</h2><blockquote>
<p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。</p>
</blockquote>
<ul>
<li>整数和小数（比如<code>1</code>、<code>1.1</code>、<code>.1</code>)。</li>
<li>也可用 科学记数法 表示: <code>1.23e2 = 123</code>。</li>
<li>二进制表示：前缀<code>0b</code>。</li>
<li>八进制表示：前缀<code>0</code>（后ES5添加<code>0o</code>）。</li>
<li>十六进制：前缀<code>0x</code>。</li>
<li><p>ES即ECMAScript：标准化JavaScript。</p>
<h2 id="字符串（string）："><a href="#字符串（string）：" class="headerlink" title="字符串（string）："></a>字符串（string）：</h2><p>定义：零或多个排在一起的字符，使用’’或””表示。</p>
</li>
<li><p><code>&#39;&#39;</code>中可以使用<code>&quot;&quot;</code>或<code>&quot;</code>，<code>&quot;&quot;</code>中可以使用<code>&#39;&#39;</code>或<code>&#39;</code>。</p>
</li>
<li>在单(双)引号中使用单(双)引号：<code>\&#39;</code> <code>\&quot;</code>。</li>
</ul>
<p>字符串只能写在一行，如果想分多行写，可以:</p>
<ul>
<li>在每一行尾加 <code>\</code>，但<code>\</code>后只能接回车换行，尤其注意不能有空格，非常坑，别这样写！</li>
<li>使用连接符<code>+</code>，行尾行首均可。</li>
<li><p>使用反引号包住多行代码，但字符串中会增加<code>换行</code>字符。</p>
<h2 id="布尔值（boolean）："><a href="#布尔值（boolean）：" class="headerlink" title="布尔值（boolean）："></a>布尔值（boolean）：</h2><p>只有表示真伪的两个特殊值，即<code>true</code>真 和 <code>false</code>假。<br><table><br><tr><th>会返回布尔值的运算符</th><td>&gt; 两元逻辑运算符： &amp;&amp; (And)，|| (Or)<br>&gt; 前置逻辑运算符： ! (Not)<br>&gt; 相等运算符：===，!==，==，!=<br>&gt; 比较运算符：&gt;，&gt;=，&lt;，&lt;=<br></td></tr><tr><th>会转为false的值</th><td>undefined、null、false、null、0、NaN、空字符串<br></td></tr><tr><th>会转为true的值</th><td>除上述的其他。包括[]、{}<br></td></tr></table></p>
<h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol:"></a>symbol:</h2><p>symbol用来生成一个全局唯一的值，但并不是字符串。symbol的名字与值无关。</p>
<h2 id="undefined："><a href="#undefined：" class="headerlink" title="undefined："></a>undefined：</h2><p>表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。一般用于不赋值的<strong>非对象</strong>：<code>var n</code>，但不是规定。</p>
<h2 id="null："><a href="#null：" class="headerlink" title="null："></a>null：</h2><p>表示空值，即此处的值为空。一般用于不赋值的<strong>对象</strong>。null转为数值时自动转为0，这样不便发现错误，于是JS之父Brendan Eich又设计了undefined，它会转为<code>NaN</code>(非数，特殊的数值)。<br><br>一个null的特例：<code>typeof null</code>值为<code>Object</code>,其它数据类型均为自身。</p>
<h2 id="对象（object）："><a href="#对象（object）：" class="headerlink" title="对象（object）："></a>对象（object）：</h2><p>对象是JS核心概念，也是最重要的数据类型。对象就是各种键值对组成的集合<code>(key-value)</code>，是以上几种基本类型的<strong>无序</strong>的组合。</p>
</li>
<li><p>object中所有<code>key</code>均为<code>string</code>，<strong>字符串</strong>。全为数字或符合标识符规范的可不加引号。</p>
</li>
<li>object中所有<code>value</code>可以为各种类型和function。类型为string时必须加引号。</li>
<li><code>Object[&#39;key&#39;]</code>，<code>key</code>必须加引号，<code>Object[key]</code>不加引号时<code>key</code>是变量，key全为数字除外，会自动转为字符串。</li>
<li><code>Object[&#39;key&#39;]</code>可以写成<code>Object.key</code>，key全为数字除外，会将<code>.</code>看成小数点。</li>
<li><code>Object[表达式]</code>是正确的，<code>Objecct[&#39;H&#39;+&#39;H&#39;]=Object[&#39;HH&#39;]</code>，注意数值键不加引号时<code>Objecct[1+2]=Object[3]</code>。</li>
<li><code>delete object[&#39;key&#39;]</code>可以删除<code>key&amp;value</code>，<code>object[&#39;key&#39;] = undefined</code>只删除<code>value</code>。</li>
<li><code>for(var key in Object)</code>可遍历对象所有可以遍历的属性，包括可以遍历的继承属性。</li>
<li><code>Object.keys()</code>API可以查看对象所有key。</li>
<li>在行首的<code>{&#39;x&#39;:&#39;y&#39;}</code>均看作代码块，所以对象要写成({‘x’:’y’})。<h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><code>typeof</code>运算符可以返回一个值的数据类型。<br><center><br><table><br><tr><th>各种值</th><th>typeof 值<br></th></tr><tr><td>string</td><td>‘string’<br></td></tr><tr><td>number</td><td>‘number’<br></td></tr><tr><td>boolean</td><td>‘boolean’<br></td></tr><tr><td>symbol</td><td>‘symbol’<br></td></tr><tr><td>undefined</td><td>‘undefined’<br></td></tr><tr><td>null<th>‘object’<br></th></td></tr><tr><td>object</td><td>‘object’<br></td></tr><tr><td>function<th>‘function’<br></th></td></tr></table><center></center></center></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/09/JS中的数据类型/" data-id="cjlrxaedb000bvw7l3qxtsfp5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS中的数据类型/">JS中的数据类型</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-css布局" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/27/css布局/" class="article-date">
  <time datetime="2018-05-27T05:04:48.000Z" itemprop="datePublished">2018-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/27/css布局/">css布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要介绍以下几点</p>
<ul>
<li>左右布局</li>
<li>水平居中</li>
<li>垂直居中</li>
</ul>
<hr>
<h2 id="左右布局（两个子元素或以上）"><a href="#左右布局（两个子元素或以上）" class="headerlink" title="左右布局（两个子元素或以上）"></a>左右布局（两个子元素或以上）</h2><ol>
<li><strong>利用浮动</strong><br><br>给所有子元素添加属性<code>float:left/right</code>，父元素添加clearfix类，可使子元素从左至右排列，同时添加<br><code>margin</code>可增加元素间距。但是当宽度大于父元素宽度时，子元素会换行显示。</li>
<li><strong>利用绝对定位</strong><br><br>父元素添加<code>position:relative</code>，所有子元素添加<code>position:absolute</code>，使子元素脱离文档流，再利用<code>top: px</code>使子元<br>素顶部对齐，同时使用left属性调整左右位置。</li>
</ol>
<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><ul>
<li><strong>行内元素&amp;类行内元素（文本、链接等）</strong><br><ol>
<li>在块级父容器中让行内元素居中，只需在<strong>父元素</strong>中使用<code>text-align: center;</code><br><br>这个方法可使<code>inline</code>、<code>inline-block</code>、<code>inline-table</code>、<code>inline</code>、<code>flex</code>等类型的元素水平居中。</li>
</ol>
</li>
<li><strong>块级元素（确定宽度）</strong><br><ol>
<li><strong>法一</strong>：将子元素<code>margin-left</code>、<code>margin-right</code>均设置为<code>auto</code>。(不确定宽度时会拉至与父元素等宽。)<br></li>
<li><strong>法二</strong>：利用绝对定位，将子元素<code>left</code>设置为父元素宽度的一半，同时<code>margin-left</code>设置为子元素宽度一半的<strong>负值</strong>。</li>
<li><strong>法3.1：</strong>利用绝对定位，并将子元素<code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code>均设置为0，并加<code>margin:auto</code>。</li>
</ol>
</li>
<li><strong>块级元素（不确定宽度）</strong><br><ol>
<li><strong>法3.2：</strong>利用绝对定位，并将子元素<code>top</code>、<code>left</code>、<code>right</code>、<code>bottom</code>均设置为0，这个方法会将子元素的宽高都拉至与父元素等宽高。<br></li>
<li><strong>法四：</strong>利用绝对定位，将子元素<code>top</code>、<code>left</code>设置为<code>50%</code>，并添加<code>transform: translate(-50%, -50%);</code> 可使子元素水平且垂直居中。<br>其中<code>left</code>、<code>translateX(-50%)</code>实现水平居中。<br></li>
<li><strong>法五：</strong> flex布局：在<strong>父元素</strong>中添加<code>display:flex;</code>、<code>justify-content:center;//水平居中</code>、<code>align-items: center;//垂直居中</code> 即可使子元素水平且垂直居中。</li>
</ol>
</li>
<li><strong>多个块级元素</strong><br><ol>
<li>对所有子元素使用<code>display:inline-block;</code>，在父元素上使用<code>text-align:center;</code>即可。</li>
<li>见<strong>法五</strong>。</li>
</ol>
</li>
</ul>
<h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><ul>
<li><strong>行内元素</strong><br><ol>
<li>在<strong>父元素</strong>中使用<code>display:table-cell;</code>、<code>vertical-align:middle;</code> 即可使子元素垂直居中。</li>
</ol>
</li>
<li><strong>块级元素（确定高度）</strong><br><ol>
<li>同理<strong>法二</strong>，利用绝对定位，将子元素<code>top</code>设置为父元素宽度的一半，同时<code>margin-top</code>设置为子元素宽度一半的 <strong>负值</strong>。</li>
<li>见<strong>法3.1</strong>。</li>
</ol>
</li>
<li><strong>块级元素（不确定高度）</strong><br><ol>
<li>见<strong>法3.2</strong>。</li>
<li>见<strong>法四</strong>。其中<code>top</code>、<code>translateY(-50%)</code>实现垂直居中。</li>
<li>见<strong>法五</strong>。</li>
</ol>
</li>
<li><strong>多个块级元素</strong><br><ol>
<li>见<strong>法五</strong>。</li>
</ol>
</li>
</ul>
<h2 id="总结居中"><a href="#总结居中" class="headerlink" title="总结居中"></a>总结居中</h2><ul>
<li><strong>行内元素</strong><ol>
<li>水平居中：在父元素中使用<code>text-align: center;</code></li>
<li>垂直居中：在父元素中使用<code>display:table-cell;</code>、<code>vertical-align:middle;</code></li>
</ol>
</li>
<li><strong>块级元素(确定宽高)</strong><ol>
<li>利用<code>margin:auto</code>：<br><br> a.水平居中：<code>margin-left</code>、<code>margin-right</code>均设置为<code>auto</code>。<br><br> b.垂直居中不适用。 </li>
<li>绝对定位 + margin负值。</li>
<li>绝对定位 + transform</li>
<li>flex布局</li>
</ol>
</li>
<li><strong>块级元素(不确定宽高)</strong><ol>
<li>绝对定位 + transform</li>
<li>flex布局</li>
</ol>
</li>
<li><strong>多个块级元素</strong><ol>
<li>对所有子元素使用<code>display:inline-block;</code>，在父元素上使用<code>text-align:center;</code> (只适用于水平居中)。</li>
<li>flex布局</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/27/css布局/" data-id="cjlrxaeea0013vw7liatoia3u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css布局/">css布局</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP请求与响应基础/">HTTP请求与响应基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS中的排序算法/">JS中的排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS中的数据类型/">JS中的数据类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS中的数据类型转换/">JS中的数据类型转换</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS数据结构/">JS数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css布局/">css布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git入门/">git入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html5标签/">html5标签</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html常用标签/">html常用标签</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery-API/">jQuery-API</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原型与原型链/">原型与原型链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/命令行基本命令/">命令行基本命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/登录注册与cookie/">登录注册与cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域之ajax/">跨域之ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域之jsonp/">跨域之jsonp</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HTTP请求与响应基础/" style="font-size: 10px;">HTTP请求与响应基础</a> <a href="/tags/JS中的排序算法/" style="font-size: 10px;">JS中的排序算法</a> <a href="/tags/JS中的数据类型/" style="font-size: 10px;">JS中的数据类型</a> <a href="/tags/JS中的数据类型转换/" style="font-size: 10px;">JS中的数据类型转换</a> <a href="/tags/JS数据结构/" style="font-size: 10px;">JS数据结构</a> <a href="/tags/css布局/" style="font-size: 10px;">css布局</a> <a href="/tags/git入门/" style="font-size: 10px;">git入门</a> <a href="/tags/html5标签/" style="font-size: 10px;">html5标签</a> <a href="/tags/html常用标签/" style="font-size: 10px;">html常用标签</a> <a href="/tags/jQuery-API/" style="font-size: 10px;">jQuery-API</a> <a href="/tags/原型与原型链/" style="font-size: 10px;">原型与原型链</a> <a href="/tags/命令行基本命令/" style="font-size: 10px;">命令行基本命令</a> <a href="/tags/登录注册与cookie/" style="font-size: 10px;">登录注册与cookie</a> <a href="/tags/跨域之ajax/" style="font-size: 10px;">跨域之ajax</a> <a href="/tags/跨域之jsonp/" style="font-size: 10px;">跨域之jsonp</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/26/登录注册与cookie/">登录注册与Cookie</a>
          </li>
        
          <li>
            <a href="/2018/08/25/JS数据结构/">JS中的数据结构</a>
          </li>
        
          <li>
            <a href="/2018/08/23/JS排序算法/">日常学习JS排序算法</a>
          </li>
        
          <li>
            <a href="/2018/08/23/AJAX/">AJAX</a>
          </li>
        
          <li>
            <a href="/2018/08/17/JSONP/">JSONP</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 lxiaox<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>